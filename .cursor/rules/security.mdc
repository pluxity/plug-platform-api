---
description: Comprehensive security coding conventions covering sensitive data handling, input validation, authentication and authorization, API security, file operations, dependency management, deployment security, and code review practices. Includes practical guidelines for preventing common vulnerabilities, implementing secure authentication flows, and maintaining security throughout the development lifecycle.
globs: 
alwaysApply: false
---
# 보안 관련 코딩 컨벤션

## 1. 민감 정보 처리

- **하드코딩 금지**: 소스 코드에 비밀번호, API 키, 토큰 등 민감 정보를 절대 하드코딩하지 않습니다.
  ```java
  // 잘못된 예:
  String apiKey = "1234abcd5678efgh";
  
  // 올바른 예:
  String apiKey = System.getenv("API_KEY");
  ```

- **환경 변수 활용**: 민감 정보는 환경 변수나 암호화된 설정 파일을 통해 관리합니다.
  - 개발 환경: .env 파일 (단, .gitignore에 반드시 포함)
  - 운영 환경: 환경 변수 또는 보안 저장소(AWS Secrets Manager, Hashicorp Vault 등)

- **암호화**: 중요 데이터는 반드시 적절한 암호화 알고리즘을 사용하여 저장합니다.
  - 비밀번호는 단방향 해시(bcrypt, Argon2 등)로 저장
  - 기타 중요 정보는 강력한 대칭/비대칭 암호화 사용

- **로깅 주의**: 로그에 민감 정보가 기록되지 않도록 합니다.
  ```java
  // 잘못된 예:
  logger.info("사용자 로그인: " + username + ", 비밀번호: " + password);
  
  // 올바른 예:
  logger.info("사용자 로그인: " + username);
  ```

## 2. 입력 검증 규칙

- **모든 사용자 입력 검증**: 신뢰할 수 없는 모든 데이터는 서버 측에서 반드시 검증합니다.
  - 클라이언트 측 검증은 UX 향상용일 뿐, 보안 목적으로는 불충분합니다.

- **입력 데이터 타입 및 범위 확인**: 입력값의 타입, 길이, 형식, 범위를 엄격하게 검사합니다.
  ```java
  // 예:
  if (age < 0 || age > 150) {
      throw new ValidationException("유효하지 않은 나이 범위입니다.");
  }
  ```

- **화이트리스트 검증**: 블랙리스트보다 화이트리스트 방식으로 허용 패턴만 검증합니다.
  ```java
  // 잘못된 예(블랙리스트):
  if (input.contains("<script>")) { reject(); }
  
  // 올바른 예(화이트리스트):
  if (!Pattern.matches("^[a-zA-Z0-9\\s]+$", input)) { reject(); }
  ```

- **SQL 인젝션 방지**: 파라미터화된 쿼리(Prepared Statement)를 항상 사용합니다.
  ```java
  // 잘못된 예:
  String query = "SELECT * FROM users WHERE username = '" + username + "'";
  
  // 올바른 예:
  String query = "SELECT * FROM users WHERE username = ?";
  PreparedStatement stmt = connection.prepareStatement(query);
  stmt.setString(1, username);
  ```

- **XSS 방지**: 출력 시 적절한 인코딩을 적용합니다.
  - HTML 컨텍스트: HTML 엔티티 인코딩
  - JavaScript 컨텍스트: JavaScript 이스케이프
  - CSS 컨텍스트: CSS 이스케이프
  - URL 파라미터: URL 인코딩

## 3. 인증 및 인가 구현 표준

- **강력한 비밀번호 정책**: 비밀번호 복잡성 요구사항을 적용합니다.
  - 최소 8자 이상
  - 대문자, 소문자, 숫자, 특수문자 조합
  - 일반적인 패턴 및 사전 단어 금지
  - 주기적 변경 (선택적)

- **다중 인증(MFA)**: 중요 기능에는 다중 인증을 구현합니다.

- **인증 토큰 관리**:
  - JWT 사용 시 만료 시간 설정 (짧게 유지)
  - 서명 알고리즘은 HS256 이상 또는 RS256 사용
  - 토큰에 민감 정보 포함 금지

- **세션 관리**:
  - 세션 ID는 무작위 생성
  - 인증 후 세션 재생성(session fixation 방지)
  - 적절한 세션 타임아웃 설정
  - 로그아웃 시 세션 폐기

- **최소 권한 원칙**: 사용자에게 필요한 최소한의 권한만 부여합니다.
  ```java
  // 예: 권한 검사
  if (!hasPermission(user, "DOCUMENT_EDIT")) {
      throw new AccessDeniedException("문서 편집 권한이 없습니다.");
  }
  ```

- **CORS 설정**: Cross-Origin Resource Sharing 설정을 엄격하게 관리합니다.
  - 신뢰할 수 있는 도메인만 허용
  - 와일드카드(*) 사용 지양

## 4. API 보안

- **레이트 리밋(Rate Limiting)**: API 호출 횟수를 제한하여 DoS 공격을 방지합니다.

- **HTTPS 필수**: 모든 통신은 HTTPS로만 이루어져야 합니다.
  - HTTP Strict Transport Security(HSTS) 헤더 사용

- **API 키 및 토큰 관리**:
  - API 키는 최소 권한으로 발급
  - 주기적인 순환 및 폐기 메커니즘 구현
  - 유효기간 설정

- **에러 메시지**: 에러 응답에 민감 정보나 상세 오류 스택트레이스를 포함하지 않습니다.
  ```java
  // 잘못된 예:
  return ResponseEntity.status(500).body(e.getStackTrace());
  
  // 올바른 예:
  logger.error("데이터베이스 오류", e); // 로깅은 상세하게
  return ResponseEntity.status(500).body("서버 오류가 발생했습니다.");
  ```

## 5. 파일 업로드 및 다운로드 보안

- **파일 검증**: 업로드된 파일의 유형, 크기, 콘텐츠를 엄격하게 검증합니다.
  - 파일 확장자 검사
  - MIME 타입 검사
  - 악성 콘텐츠 스캔 (가능한 경우)

- **안전한 저장**: 업로드된 파일은 웹 루트 외부에 저장합니다.

- **파일 접근 제어**: 다운로드 시 권한 검사를 수행합니다.

## 6. 의존성 관리

- **라이브러리 취약점 정기 점검**: 정기적으로 의존성 취약점을 검사합니다.
  - OWASP Dependency Check 또는 Snyk 등 도구 활용

- **최신 버전 유지**: 보안 패치가 적용된 최신 버전 사용을 권장합니다.

- **사용하지 않는 의존성 제거**: 불필요한 의존성은 제거하여 공격 표면을 줄입니다.

## 7. 배포 및 인프라 보안

- **보안 설정 확인**: 서버, 데이터베이스, 웹 서버 등의 보안 설정을 확인합니다.
  - 기본 계정 및 비밀번호 변경
  - 불필요한 서비스 비활성화
  - 방화벽 및 네트워크 접근 제한

- **컨테이너 보안**: 컨테이너 이미지 취약점 검사를 수행합니다.

- **시크릿 관리**: 배포 파이프라인에서 시크릿 관리 도구를 사용합니다.

## 8. 보안 코드 리뷰

- **보안 관점의 코드 리뷰**: 모든 코드 리뷰에서 보안 문제를 확인합니다.
  - OWASP Top 10 취약점 확인
  - 보안 안티패턴 식별

- **자동화된 보안 검사**: 정적 분석 도구를 CI/CD 파이프라인에 통합합니다.
  - SonarQube, Checkmarx, Fortify 등 활용

  # 백엔드 보안 가이드라인 컨벤션

## 개요

이 문서는 백엔드 시스템의 보안에 관한 코딩 컨벤션을 정의합니다. Spring Security 설정, 인증/인가 구현, 민감 정보 처리, 보안 취약점 방어 등에 대한 일관된 규칙을 통해 안전한 애플리케이션을 구축하는 것을 목표로 합니다.

## Spring Security 구성

### 기본 설정 가이드

Spring Security 설정은 `SecurityFilterChain` 빈을 정의하는 Java Configuration 방식을 사용합니다.

```java
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final JwtAccessDeniedHandler accessDeniedHandler;
    private final JwtAuthenticationEntryPoint authenticationEntryPoint;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())  // JWT 사용 시 비활성화 (별도 CSRF 대응 방안 마련)
            .formLogin(formLogin -> formLogin.disable())  // REST API에서는 폼 로그인 비활성화
            .httpBasic(httpBasic -> httpBasic.disable())  // HTTP 기본 인증 비활성화
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS))  // JWT 사용 시 세션 비활성화
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                .requestMatchers("/api/v1/admin/**").hasRole("ADMIN")
                .anyRequest().authenticated())
            .exceptionHandling(exception -> exception
                .accessDeniedHandler(accessDeniedHandler)
                .authenticationEntryPoint(authenticationEntryPoint))
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 보안 설정 분리

대규모 애플리케이션의 경우 보안 설정을 여러 클래스로 분리합니다.

```java
@Configuration
@EnableMethodSecurity  // 메소드 수준 보안 활성화
public class MethodSecurityConfig {
    // 메소드 수준 보안 설정
}

@Configuration
public class CorsConfig {
    @Bean
    public CorsFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowCredentials(true);
        config.addAllowedOrigin("https://frontend.example.com");
        config.addAllowedHeader("*");
        config.addAllowedMethod("*");
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", config);
        return new CorsFilter(source);
    }
}
```

## 인증(Authentication) 구현

### JWT 기반 인증

JWT(JSON Web Token)를 사용한 인증 구현 가이드입니다.

#### JWT 설정 클래스
```java
@Component
@ConfigurationProperties(prefix = "jwt")
@Getter
@Setter
public class JwtProperties {
    private String secretKey;
    private long accessTokenValidityInSeconds;
    private long refreshTokenValidityInSeconds;
}

@Component
@RequiredArgsConstructor
public class JwtTokenProvider {
    private final JwtProperties jwtProperties;
    private final UserDetailsService userDetailsService;
    
    private Key key;
    
    @PostConstruct
    public void init() {
        byte[] keyBytes = Decoders.BASE64.decode(jwtProperties.getSecretKey());
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }
    
    public String createToken(Authentication authentication) {
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));
        
        long now = (new Date()).getTime();
        Date validity = new Date(now + jwtProperties.getAccessTokenValidityInSeconds() * 1000);
        
        return Jwts.builder()
                .setSubject(authentication.getName())
                .claim("auth", authorities)
                .signWith(key, SignatureAlgorithm.HS512)
                .setExpiration(validity)
                .compact();
    }
    
    public Authentication getAuthentication(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(token)
                .getBody();
        
        UserDetails userDetails = userDetailsService.loadUserByUsername(claims.getSubject());
        return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

#### JWT 필터 구현
```java
@Component
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider tokenProvider;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String token = resolveToken(request);
        
        if (StringUtils.hasText(token) && tokenProvider.validateToken(token)) {
            Authentication authentication = tokenProvider.getAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### OAuth2 연동

소셜 로그인을 위한 OAuth2 구현 가이드입니다.

```java
@Configuration
@RequiredArgsConstructor
public class OAuth2Config {
    private final CustomOAuth2UserService customOAuth2UserService;
    private final OAuth2AuthenticationSuccessHandler oAuth2AuthenticationSuccessHandler;
    private final OAuth2AuthenticationFailureHandler oAuth2AuthenticationFailureHandler;
    
    @Bean
    public SecurityFilterChain oauth2FilterChain(HttpSecurity http) throws Exception {
        return http
            // 기본 설정
            .oauth2Login(oauth2 -> oauth2
                .authorizationEndpoint(endpoint -> endpoint
                    .baseUri("/oauth2/authorize")
                    .authorizationRequestRepository(cookieAuthorizationRequestRepository()))
                .redirectionEndpoint(endpoint -> endpoint
                    .baseUri("/oauth2/callback/*"))
                .userInfoEndpoint(endpoint -> endpoint
                    .userService(customOAuth2UserService))
                .successHandler(oAuth2AuthenticationSuccessHandler)
                .failureHandler(oAuth2AuthenticationFailureHandler))
            .build();
    }
    
    @Bean
    public AuthorizationRequestRepository<OAuth2AuthorizationRequest> cookieAuthorizationRequestRepository() {
        return new HttpCookieOAuth2AuthorizationRequestRepository();
    }
}

@Service
@RequiredArgsConstructor
public class CustomOAuth2UserService extends DefaultOAuth2UserService {
    private final UserRepository userRepository;
    
    @Override
    public OAuth2User loadUser(OAuth2UserRequest userRequest) throws OAuth2AuthenticationException {
        OAuth2User oAuth2User = super.loadUser(userRequest);
        
        // OAuth2 공급자와 사용자 정보로 사용자 처리
        String provider = userRequest.getClientRegistration().getRegistrationId();
        String providerId = oAuth2User.getAttribute("sub");
        String email = oAuth2User.getAttribute("email");
        
        User user = userRepository.findByEmail(email)
                .orElseGet(() -> createUser(email, provider, providerId, oAuth2User));
        
        return UserPrincipal.create(user, oAuth2User.getAttributes());
    }
    
    private User createUser(String email, String provider, String providerId, OAuth2User oAuth2User) {
        User user = User.builder()
                .email(email)
                .name(oAuth2User.getAttribute("name"))
                .provider(provider)
                .providerId(providerId)
                .role(Role.USER)
                .build();
        
        return userRepository.save(user);
    }
}
```

## 인가(Authorization) 구현

### 메소드 보안 활용

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    
    // 관리자 권한 필요
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public List<UserDto> getAllUsers() {
        // ...
    }
    
    // 자신의 정보만 조회 가능
    @PreAuthorize("#id == authentication.principal.id or hasRole('ROLE_ADMIN')")
    public UserDto getUserById(Long id) {
        // ...
    }
    
    // 데이터 소유자 확인
    @PostAuthorize("returnObject.userId == authentication.principal.id")
    public OrderDto getOrder(Long orderId) {
        // ...
    }
}
```

### 리소스 소유자 확인 유틸리티

```java
@Component
@RequiredArgsConstructor
public class SecurityUtils {
    public static boolean isResourceOwner(UserDetails userDetails, Long resourceOwnerId) {
        return userDetails.getUsername().equals(resourceOwnerId.toString());
    }
    
    public static boolean isAdmin(UserDetails userDetails) {
        return userDetails.getAuthorities().stream()
                .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }
    
    public static String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated()) {
            return null;
        }
        
        Object principal = authentication.getPrincipal();
        if (principal instanceof UserDetails) {
            return ((UserDetails) principal).getUsername();
        }
        return principal.toString();
    }
}
```

## 민감 정보 처리

### 패스워드 관리

```java
@Service
@RequiredArgsConstructor
public class UserService {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    
    public void registerUser(UserRegistrationDto dto) {
        // 비밀번호 해싱
        String hashedPassword = passwordEncoder.encode(dto.getPassword());
        
        User user = User.builder()
                .email(dto.getEmail())
                .password(hashedPassword)  // 항상 해싱된 패스워드만 저장
                .name(dto.getName())
                .role(Role.USER)
                .build();
        
        userRepository.save(user);
    }
    
    public void changePassword(Long userId, ChangePasswordDto dto) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new UserNotFoundException(userId));
        
        // 현재 비밀번호 확인
        if (!passwordEncoder.matches(dto.getCurrentPassword(), user.getPassword())) {
            throw new InvalidPasswordException("현재 비밀번호가 일치하지 않습니다.");
        }
        
        // 새 비밀번호 해싱
        String newHashedPassword = passwordEncoder.encode(dto.getNewPassword());
        user.updatePassword(newHashedPassword);
        
        userRepository.save(user);
    }
}
```

### PII(개인 식별 정보) 암호화

개인 식별 정보는 암호화하여 저장합니다.

```java
@Converter
public class StringCryptoConverter implements AttributeConverter<String, String> {
    private static final String SECRET_KEY = "your-secret-key";  // 실제로는 외부 설정에서 가져와야 함
    private static final String ALGORITHM = "AES/ECB/PKCS5Padding";
    
    @Override
    public String convertToDatabaseColumn(String attribute) {
        if (attribute == null) {
            return null;
        }
        try {
            SecretKeySpec secretKey = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, secretKey);
            return Base64.getEncoder().encodeToString(cipher.doFinal(attribute.getBytes()));
        } catch (Exception e) {
            throw new RuntimeException("Error encrypting data", e);
        }
    }
    
    @Override
    public String convertToEntityAttribute(String dbData) {
        if (dbData == null) {
            return null;
        }
        try {
            SecretKeySpec secretKey = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
            Cipher cipher = Cipher.getInstance(ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, secretKey);
            return new String(cipher.doFinal(Base64.getDecoder().decode(dbData)));
        } catch (Exception e) {
            throw new RuntimeException("Error decrypting data", e);
        }
    }
}

@Entity
@Table(name = "users")
public class User {
    // ...
    
    @Convert(converter = StringCryptoConverter.class)
    @Column(name = "ssn")
    private String socialSecurityNumber;  // 암호화된 주민번호
    
    @Convert(converter = StringCryptoConverter.class)
    @Column(name = "phone_number")
    private String phoneNumber;  // 암호화된 전화번호
}
```

### 환경 변수 및 외부 설정

민감한 정보는 환경 변수나 외부 설정을 통해 관리합니다.

```yaml
# application.yml
spring:
  datasource:
    url: ${DB_URL}
    username: ${DB_USERNAME}
    password: ${DB_PASSWORD}
  
  security:
    oauth2:
      client:
        registration:
          google:
            client-id: ${GOOGLE_CLIENT_ID}
            client-secret: ${GOOGLE_CLIENT_SECRET}
```

### Vault 활용

대규모 환경에서는 HashiCorp Vault와 같은 비밀 관리 도구를 활용합니다.

```java
@Configuration
@EnableVaultPropertySource
public class VaultConfig {
    @Value("${spring.cloud.vault.token}")
    private String vaultToken;
    
    @Bean
    public VaultTemplate vaultTemplate() {
        VaultEndpoint endpoint = new VaultEndpoint();
        endpoint.setHost("vault.example.com");
        endpoint.setPort(8200);
        
        ClientAuthentication clientAuthentication = new TokenAuthentication(vaultToken);
        return new VaultTemplate(endpoint, clientAuthentication);
    }
}
```

## CSRF/XSS 대응 방안

### CSRF 방어

상태가 있는 웹 애플리케이션에서는 CSRF 보호를 활성화합니다.

```java
@Configuration
public class WebSecurityConfig {
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringRequestMatchers("/api/v1/auth/**"))
            // 기타 설정...
            .build();
    }
}
```

### XSS 방어

XSS 공격을 방지하기 위한 입력 검증 및 출력 인코딩을 구현합니다.

```java
@Component
public class XssProtectionFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        XssProtectionRequestWrapper wrappedRequest = new XssProtectionRequestWrapper(request);
        filterChain.doFilter(wrappedRequest, response);
    }
}

public class XssProtectionRequestWrapper extends HttpServletRequestWrapper {
    public XssProtectionRequestWrapper(HttpServletRequest request) {
        super(request);
    }
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return value == null ? null : Jsoup.clean(value, Safelist.basic());
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values == null) {
            return null;
        }
        
        String[] cleanValues = new String[values.length];
        for (int i = 0; i < values.length; i++) {
            cleanValues[i] = Jsoup.clean(values[i], Safelist.basic());
        }
        return cleanValues;
    }
}
```

### Content Security Policy

Content Security Policy를 설정하여 XSS 방어를 강화합니다.

```java
@Component
public class ContentSecurityPolicyFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        response.setHeader("Content-Security-Policy", 
                "default-src 'self'; " +
                "script-src 'self' https://trusted-cdn.com; " +
                "style-src 'self' https://trusted-cdn.com; " +
                "img-src 'self' data: https:; " +
                "font-src 'self' https://trusted-cdn.com; " +
                "connect-src 'self' https://api.example.com; " +
                "frame-ancestors 'none'; " +
                "form-action 'self';");
        
        filterChain.doFilter(request, response);
    }
}
```

## 기타 보안 강화 방안

### 보안 헤더 설정

```java
@Component
public class SecurityHeadersFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        // X-XSS-Protection
        response.setHeader("X-XSS-Protection", "1; mode=block");
        
        // X-Content-Type-Options
        response.setHeader("X-Content-Type-Options", "nosniff");
        
        // X-Frame-Options
        response.setHeader("X-Frame-Options", "DENY");
        
        // Strict-Transport-Security
        response.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
        
        // Referrer-Policy
        response.setHeader("Referrer-Policy", "no-referrer-when-downgrade");
        
        // Permissions-Policy
        response.setHeader("Permissions-Policy", "camera=(), microphone=(), geolocation=()");
        
        filterChain.doFilter(request, response);
    }
}
```

### SQL 인젝션 방지

JPA 및 Hibernate 사용 시 자동으로 SQL 인젝션이 방지되지만, 네이티브 쿼리 사용 시 주의가 필요합니다.

```java
// 안전한 쿼리 파라미터 바인딩
@Query(value = "SELECT * FROM users WHERE email = :email", nativeQuery = true)
User findByEmailNative(@Param("email") String email);

// 안전하지 않은 방식 - 사용 금지
@Query(value = "SELECT * FROM users WHERE email = '" + email + "'", nativeQuery = true)  // SQL 인젝션 위험!
```

### 요청 제한(Rate Limiting)

API 요청 제한을 통해 무차별 대입 공격 등을 방어합니다.

```java
@Configuration
@EnableRedisHttpSession
public class HttpSessionConfig {
    @Bean
    public RateLimiter rateLimiter(RedisTemplate<String, Integer> redisTemplate) {
        return new RedisRateLimiter(redisTemplate);
    }
}

@Component
@RequiredArgsConstructor
public class RateLimitFilter extends OncePerRequestFilter {
    private final RateLimiter rateLimiter;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String clientIp = getClientIp(request);
        
        if (!rateLimiter.allowRequest(clientIp)) {
            response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            response.getWriter().write("Too many requests");
            return;
        }
        
        filterChain.doFilter(request, response);
    }
    
    private String getClientIp(HttpServletRequest request) {
        String xfHeader = request.getHeader("X-Forwarded-For");
        if (xfHeader == null) {
            return request.getRemoteAddr();
        }
        return xfHeader.split(",")[0];
    }
}
```

## 보안 감사 및 모니터링

### 보안 이벤트 로깅

```java
@Aspect
@Component
@RequiredArgsConstructor
public class SecurityEventLogger {
    private final Logger logger = LoggerFactory.getLogger(SecurityEventLogger.class);
    
    @Pointcut("execution(* com.example.service.UserService.login(..))")
    public void loginPointcut() {}
    
    @Pointcut("execution(* com.example.service.UserService.changePassword(..))")
    public void passwordChangePointcut() {}
    
    @AfterReturning("loginPointcut()")
    public void logSuccessfulLogin(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        String username = (String) args[0];
        logger.info("User logged in successfully: {}", username);
    }
    
    @AfterThrowing(value = "loginPointcut()", throwing = "ex")
    public void logFailedLogin(JoinPoint joinPoint, Exception ex) {
        Object[] args = joinPoint.getArgs();
        String username = (String) args[0];
        logger.warn("Failed login attempt: {}, reason: {}", username, ex.getMessage());
    }
    
    @Around("passwordChangePointcut()")
    public Object logPasswordChange(ProceedingJoinPoint joinPoint) throws Throwable {
        Object[] args = joinPoint.getArgs();
        Long userId = (Long) args[0];
        
        try {
            Object result = joinPoint.proceed();
            logger.info("Password changed for user ID: {}", userId);
            return result;
        } catch (Exception ex) {
            logger.warn("Failed password change for user ID: {}, reason: {}", userId, ex.getMessage());
            throw ex;
        }
    }
}
```

### 보안 알림 설정

```java
@Service
@RequiredArgsConstructor
public class SecurityAlertService {
    private final EmailService emailService;
    private final SmsService smsService;
    private final AdminRepository adminRepository;
    
    @Async
    public void alertAdminsForSuspiciousActivity(String username, String activityType, String details) {
        String subject = "보안 경고: 의심스러운 활동 감지";
        String message = String.format("사용자 %s에 대한 의심스러운 %s 활동이 감지되었습니다.\n세부 정보: %s",
                username, activityType, details);
        
        // 관리자에게 알림
        List<Admin> admins = adminRepository.findAllActiveAdmins();
        for (Admin admin : admins) {
            emailService.sendEmail(admin.getEmail(), subject, message);
            if (admin.isReceiveSmsAlerts()) {
                smsService.sendSms(admin.getPhoneNumber(), "보안 경고: " + username);
            }
        }
    }
}
```

## 보안 체크리스트

시스템 배포 전 확인해야 할 보안 체크리스트입니다:

1. **인증 및 인가**
   - [ ] 모든 API 엔드포인트에 적절한 인증 검사 적용
   - [ ] 역할 기반 권한 제어 적용
   - [ ] JWT 토큰의 만료 시간 설정

2. **암호화**
   - [ ] 모든 비밀번호 해싱 처리
   - [ ] PII 데이터 암호화
   - [ ] TLS/SSL 통신 적용

3. **입력 검증**
   - [ ] 모든 사용자 입력에 유효성 검사 적용
   - [ ] SQL 인젝션 방지 검증
   - [ ] XSS 방어 검증

4. **보안 헤더**
   - [ ] 모든 보안 관련 HTTP 헤더 설정
   - [ ] CSP(Content Security Policy) 설정
   - [ ] CORS 설정 검증

5. **민감 정보 관리**
   - [ ] 민감 정보가 로그에 노출되지 않는지 확인
   - [ ] 환경 변수 또는 보안 저장소를 통한 시크릿 관리
   - [ ] 민감 정보의 응답으로 노출되지 않는지 확인

6. **로깅 및 모니터링**
   - [ ] 보안 관련 이벤트 로깅 확인
   - [ ] 비정상적인 활동에 대한 알림 설정
   - [ ] 로그인 실패 시도에 대한 모니터링

7. **기타**
   - [ ] 요청 제한(Rate Limiting) 적용
   - [ ] 정기적인 보안 업데이트 계획
   - [ ] 보안 관련 의존성 취약점 스캔

## 참고 문헌

- [OWASP Top 10](mdc:https:/owasp.org/www-project-top-ten)
- [Spring Security 공식 문서](mdc:https:/docs.spring.io/spring-security/reference/index.html)
- [JWT 보안 모범 사례](mdc:https:/curity.io/resources/learn/jwt-best-practices)
- [NIST 암호화 표준](mdc:https:/www.nist.gov/cybersecurity)
