---
description:  Backend database design conventions providing comprehensive guidelines for database schema modeling, JPA entity implementation, relationship mapping patterns, naming standards, auditing fields, value objects, indexing strategies, data type mappings, N+1 problem solutions, and security best practices for handling sensitive data in backend systems.
globs: 
alwaysApply: false
---
# 백엔드 데이터베이스 설계 컨벤션

## 개요

이 문서는 백엔드 시스템의 데이터베이스 설계에 관한 코딩 컨벤션을 정의합니다. 데이터베이스 스키마, JPA 엔티티, 연관관계 매핑 등에 대한 일관된 규칙을 통해 안정적이고 효율적인 데이터 계층을 구축하는 것을 목표로 합니다.

## 데이터베이스 명명 규칙

### 테이블 명명 규칙
- 테이블 이름은 **스네이크 케이스**(snake_case)로 작성
- 약어를 사용하지 않는다.
- 조인 테이블은 연결하는 두 테이블 이름을 조합 (예: `order_items`, `user_roles`)

### 컬럼 명명 규칙
- 컬럼 이름은 **스네이크 케이스**로 작성
- 식별자(ID) 컬럼은 `id` 또는 `테이블명_id` 형식 사용
- 날짜/시간 관련 컬럼은 접미사로 `_at` 사용 (예: `created_at`, `updated_at`)
- 불리언 컬럼은 `is_`, `has_` 등의 접두사 사용 (예: `is_active`, `has_children`)

### 제약조건 명명 규칙
- 기본 키: `pk_테이블명`
- 외래 키: `fk_참조테이블명_대상테이블명`
- 유니크 제약조건: `uq_테이블명_컬럼명`
- 인덱스: `idx_테이블명_컬럼명`

```sql
-- 좋은 예
CREATE TABLE order_items (
  id BIGINT PRIMARY KEY,
  order_id BIGINT NOT NULL,
  product_id BIGINT NOT NULL,
  quantity INT NOT NULL,
  price DECIMAL(10,2) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  CONSTRAINT fk_order_items_orders FOREIGN KEY (order_id) REFERENCES orders(id),
  CONSTRAINT fk_order_items_products FOREIGN KEY (product_id) REFERENCES products(id)
);
```

## JPA 엔티티 설계

### 기본 원칙
- 모든 엔티티 클래스는 `@Entity` 어노테이션 사용
- 테이블명은 `@Table(name = "테이블명")` 으로 명시적 지정
- 식별자는 `@Id`와 적절한 생성 전략 사용
- 모든 필드에 명시적으로 `@Column` 어노테이션 사용 (nullable, length 등 속성 지정)

```java
@Entity
@Table(name = "users")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class User {
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "username", nullable = false, length = 50, unique = true)
    private String username;
    
    @Column(name = "email", nullable = false, length = 100, unique = true)
    private String email;
    
    @Column(name = "is_active", nullable = false)
    private boolean active = true;
    
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @Builder
    public User(String username, String email) {
        this.username = username;
        this.email = email;
        this.createdAt = LocalDateTime.now();
    }
}
```

### 감사(Auditing) 필드
- 모든 엔티티에 생성 및 수정 시간 필드 포함
- Spring Data JPA의 `@CreatedDate`, `@LastModifiedDate` 활용
- 가능한 경우 생성자, 수정자 정보도 포함

```java
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public abstract class BaseTimeEntity {
    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;
    
    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}

@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
@Getter
public abstract class BaseEntity extends BaseTimeEntity {
    @CreatedBy
    @Column(name = "created_by", updatable = false)
    private String createdBy;
    
    @LastModifiedBy
    @Column(name = "updated_by")
    private String updatedBy;
}
```

## 연관관계 매핑

### 기본 원칙
- 모든 연관관계의 패치 전략은 **LAZY** 로딩으로 설정
- 양방향 연관관계에서는 항상 연관관계 편의 메소드 구현
- 불필요한 양방향 연관관계 지양 (필요한 경우에만 사용)
- `@JoinColumn` 어노테이션으로 외래 키 이름 명시적 지정

### 단방향 연관관계
```java
@Entity
@Table(name = "orders")
@Getter
public class Order extends BaseEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    // 기타 필드 및 메소드...
}
```

### 양방향 연관관계
```java
@Entity
@Table(name = "orders")
@Getter
public class Order extends BaseEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
    
    @OneToMany(mappedBy = "order", cascade = CascadeType.PERSIST, orphanRemoval = true)
    private List<OrderItem> orderItems = new ArrayList<>();
    
    // 연관관계 편의 메소드
    public void addOrderItem(OrderItem orderItem) {
        this.orderItems.add(orderItem);
        orderItem.setOrder(this);
    }
    
    public void removeOrderItem(OrderItem orderItem) {
        this.orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }
}

@Entity
@Table(name = "order_items")
@Getter
public class OrderItem extends BaseEntity {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;
    
    // 주문-주문상품 관계에서는 연관관계의 주인이 OrderItem
    protected void setOrder(Order order) {
        this.order = order;
    }
}
```

## 값 객체(Value Object) 설계

### 값 객체 사용 원칙
- 개념적으로 하나의 값을 표현하는 속성 집합은 값 객체로 추출
- 값 객체는 불변(immutable)으로 설계
- `@Embeddable`과 `@Embedded` 어노테이션 사용

```java
@Embeddable
@Getter
@EqualsAndHashCode
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Address {
    @Column(name = "zip_code", length = 10)
    private String zipCode;
    
    @Column(name = "address1", length = 100)
    private String address1;
    
    @Column(name = "address2", length = 100)
    private String address2;
    
    @Builder
    public Address(String zipCode, String address1, String address2) {
        this.zipCode = zipCode;
        this.address1 = address1;
        this.address2 = address2;
    }
    
    // 값 객체는 수정자 메소드 없이 새 객체 생성
    public Address withZipCode(String newZipCode) {
        return new Address(newZipCode, this.address1, this.address2);
    }
}

@Entity
@Table(name = "users")
@Getter
public class User extends BaseEntity {
    // 기본 필드...
    
    @Embedded
    private Address address;
    
    // 필드명 오버라이드가 필요한 경우
    @Embedded
    @AttributeOverrides({
        @AttributeOverride(name = "zipCode", column = @Column(name = "work_zip_code")),
        @AttributeOverride(name = "address1", column = @Column(name = "work_address1")),
        @AttributeOverride(name = "address2", column = @Column(name = "work_address2"))
    })
    private Address workAddress;
}
```

## 인덱스 설계

### 인덱스 설계 원칙
- 자주 조회되는 컬럼에 인덱스 추가
- 외래 키 컬럼은 항상 인덱스 생성
- 복합 인덱스는 선택성(selectivity)이 높은 컬럼을 먼저 배치
- 과도한 인덱스는 삽입/수정 성능에 영향을 주므로 주의

### JPA에서 인덱스 지정
```java
@Entity
@Table(
    name = "products",
    indexes = {
        @Index(name = "idx_products_name", columnList = "name"),
        @Index(name = "idx_products_category_id_price", columnList = "category_id, price")
    }
)
public class Product extends BaseEntity {
    // 엔티티 필드...
}
```

## 데이터 타입 매핑

### 데이터 타입 선택 가이드
- 문자열: 길이가 제한된 경우 `VARCHAR`, 긴 텍스트는 `TEXT`
- 숫자: 정수는 `INTEGER/BIGINT`, 정확한 소수는 `DECIMAL`
- 날짜/시간: `LocalDate`, `LocalTime`, `LocalDateTime` 사용
- 불리언: `BOOLEAN` 타입 사용
- 열거형: `@Enumerated(EnumType.STRING)` 사용 (숫자 타입 지양)

```java
@Entity
@Table(name = "products")
public class Product extends BaseEntity {
    // 기본 필드...
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false, length = 20)
    private ProductStatus status = ProductStatus.ACTIVE;
    
    @Column(name = "price", nullable = false, precision = 10, scale = 2)
    private BigDecimal price;
    
    @Column(name = "description", columnDefinition = "TEXT")
    private String description;
}
```

## N+1 문제 해결 전략

### 페치 조인(Fetch Join) 활용
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("SELECT o FROM Order o JOIN FETCH o.user WHERE o.id = :id")
    Optional<Order> findByIdWithUser(@Param("id") Long id);
    
    @Query("SELECT o FROM Order o JOIN FETCH o.orderItems WHERE o.id = :id")
    Optional<Order> findByIdWithOrderItems(@Param("id") Long id);
}
```

### EntityGraph 활용
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    @EntityGraph(attributePaths = {"user", "orderItems"})
    Optional<Order> findWithUserAndItemsById(Long id);
}
```

### 배치 로딩(Batch Fetching)
```java
@Entity
@Table(name = "orders")
public class Order extends BaseEntity {
    // 기본 필드...
    
    @BatchSize(size = 100)
    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();
}

// 또는 application.yml에 글로벌 설정
// spring.jpa.properties.hibernate.default_batch_fetch_size: 100
```

## 보안 관련 가이드라인

### 민감 데이터 처리
- 패스워드는 항상 단방향 해싱 처리 (BCrypt 등 사용)
- 개인 식별 정보(PII)는 암호화 저장
- 신용카드 정보 등 금융 데이터는 PCI DSS 준수

```java
@Entity
@Table(name = "users")
public class User extends BaseEntity {
    // 기본 필드...
    
    @Column(name = "password", nullable = false)
    private String password;  // BCrypt로 해싱된 비밀번호 저장
    
    @Convert(converter = EncryptedStringConverter.class)
    @Column(name = "social_security_number")
    private String socialSecurityNumber;  // 암호화된 주민번호
}
```