---
description: Comprehensive RESTful API design conventions providing best practices for resource-oriented architecture. Includes guidelines for URI structure, HTTP method usage, status codes, request/response formats, filtering, sorting, pagination, versioning strategies, authentication methods, error handling patterns, HATEOAS implementation, caching, and documentation standards to ensure consistent and intuitive APIs.
globs: 
alwaysApply: false
---

# RESTful API 설계 컨벤션

이 문서는 RESTful API를 설계하고 구현하기 위한 모범 사례와 가이드라인을 제공합니다. 일관되고 직관적인 API는 개발자 경험을 향상시키고 시스템 통합을 용이하게 합니다.

## 목차

- [핵심 원칙](mdc:#핵심-원칙)
- [URI 설계](mdc:#uri-설계)
- [HTTP 메서드](mdc:#http-메서드)
- [상태 코드](mdc:#상태-코드)
- [요청 및 응답 형식](mdc:#요청-및-응답-형식)
- [필터링, 정렬, 페이징](mdc:#필터링-정렬-페이징)
- [버전 관리](mdc:#버전-관리)
- [인증 및 권한](mdc:#인증-및-권한)
- [에러 처리](mdc:#에러-처리)
- [HATEOAS](mdc:#hateoas)
- [캐싱](mdc:#캐싱)
- [문서화](mdc:#문서화)

## 핵심 원칙

REST(Representational State Transfer)는 다음 원칙을 기반으로 합니다:

1. **리소스 중심 설계**: 모든 것은 리소스로 식별되며 URI로 표현됩니다.
2. **HTTP 메서드 활용**: 표준 HTTP 메서드를 사용하여 리소스에 대한 작업을 표현합니다.
3. **무상태(Stateless)**: 각 요청은 독립적으로 처리되며, 서버는 클라이언트 상태를 저장하지 않습니다.
4. **표현(Representation)**: 리소스는 다양한 형식(JSON, XML 등)으로 표현될 수 있습니다.
5. **연결성(HATEOAS)**: 응답에는 관련 리소스로의 링크가 포함될 수 있습니다.

## URI 설계

URI는 리소스를 명확하게 식별하고 일관된 패턴을 따라야 합니다.

### 기본 규칙

- 명사 복수형을 사용하여 리소스 컬렉션 표현
- 소문자 사용
- 하이픈(`-`)을 사용하여 단어 구분 (언더스코어 지양)
- 파일 확장자 사용 지양
- 마지막 슬래시(`/`) 생략

```
// Bad
GET /User/1
GET /get-user/1
GET /users/get/1
GET /api/v1/users/1/

// Good
GET /users/1
GET /users/1/orders
```

### 계층 관계

자원 간의 계층 관계는 경로로 표현합니다.

```
// Bad
GET /users?id=1&getOrders=true

// Good
GET /users/1/orders
```

### 컨트롤러 리소스

표준 CRUD 작업으로 표현하기 어려운 작업은 컨트롤러 리소스를 사용할 수 있습니다.

```
// Bad
GET /users/1/make-admin

// Good
POST /users/1/roles
PATCH /users/1 (body: {"role": "admin"})

// 복잡한 작업의 경우 컨트롤러 사용 가능
POST /users/1/actions/activate
POST /orders/1/actions/cancel
```

## HTTP 메서드

각 HTTP 메서드를 올바른 의미로 사용합니다.

| 메서드 | 설명 | 멱등성 | 안전성 |
|--------|------|--------|--------|
| GET | 리소스 조회 | Yes | Yes |
| POST | 리소스 생성 또는 프로세스 실행 | No | No |
| PUT | 리소스 전체 교체 | Yes | No |
| PATCH | 리소스 부분 업데이트 | No | No |
| DELETE | 리소스 삭제 | Yes | No |

### 메서드 사용 예시

```
// 사용자 목록 조회
GET /users

// 특정 사용자 조회
GET /users/123

// 새 사용자 생성
POST /users
Body: { "name": "John Doe", "email": "john@example.com" }

// 사용자 정보 전체 교체
PUT /users/123
Body: { "name": "John Doe", "email": "john@example.com", "role": "user" }

// 사용자 정보 부분 업데이트
PATCH /users/123
Body: { "email": "newemail@example.com" }

// 사용자 삭제
DELETE /users/123
```

## 상태 코드

적절한 HTTP 상태 코드를 사용하여 응답 상태를 표현합니다.

### 주요 상태 코드

- **2xx**: 성공
  - 200 OK: 요청 성공
  - 201 Created: 리소스 생성 성공
  - 204 No Content: 성공했지만 반환할 내용 없음

- **4xx**: 클라이언트 오류
  - 400 Bad Request: 잘못된 요청
  - 401 Unauthorized: 인증 필요
  - 403 Forbidden: 권한 없음
  - 404 Not Found: 리소스 없음
  - 409 Conflict: 리소스 충돌

- **5xx**: 서버 오류
  - 500 Internal Server Error: 서버 내부 오류

### 상태 코드 사용 예시

```
// Bad
POST /users
Response: 200 OK
Body: { "success": true, "message": "User created" }

// Good
POST /users
Response: 201 Created
Body: { "id": 123, "name": "John Doe", "email": "john@example.com" }
```

## 요청 및 응답 형식

일관된 데이터 형식을 사용합니다.

### 기본 규칙

- JSON 형식을 기본으로 사용
- 요청 헤더에 `Content-Type: application/json` 명시
- camelCase 사용 (일관성 유지)
- 응답 구조 표준화

### 응답 형식 예시

```json
// 기본 응답
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "createdAt": "2023-09-15T14:30:00Z"
}

// 컬렉션 응답
{
  "data": [
    {
      "id": 123,
      "name": "John Doe"
    },
    {
      "id": 124,
      "name": "Jane Smith"
    }
  ],
  "pagination": {
    "totalItems": 50,
    "totalPages": 5,
    "currentPage": 1,
    "pageSize": 10
  }
}
```

## 필터링, 정렬, 페이징

컬렉션 리소스 조회 시 필터링, 정렬, 페이징 기능을 제공합니다.

### 쿼리 파라미터 사용

```
// 필터링
GET /users?status=active
GET /users?role=admin&status=active

// 정렬
GET /users?sort=name
GET /users?sort=+name (오름차순)
GET /users?sort=-createdAt (내림차순)

// 페이징
GET /users?page=2&pageSize=10
GET /users?offset=20&limit=10
```

## 버전 관리

API 변경 시 이전 버전과의 호환성을 위해 버전 관리가 필요합니다.

### 버전 관리 방법

1. **URI 경로 사용**
```
GET /api/v1/users
GET /api/v2/users
```

2. **헤더 사용**
```
GET /api/users
Accept: application/vnd.company.api+json;version=1
```

3. **쿼리 파라미터 사용**
```
GET /api/users?version=1
```

URI 경로를 통한 버전 관리가 가장 명시적이고 사용하기 쉽습니다.

## 인증 및 권한

API 접근 제어를 위한 인증 및 권한 방식을 표준화합니다.

### 일반적인 방법

1. **API 키 인증**
```
GET /api/users
X-API-Key: abcd1234
```

2. **JWT 인증**
```
GET /api/users
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

3. **OAuth 2.0**
```
GET /api/users
Authorization: Bearer ACCESS_TOKEN
```

## 에러 처리

일관된 에러 응답 형식을 사용하여 클라이언트가 쉽게 처리할 수 있도록 합니다.

### 에러 응답 형식

```json
{
  "error": {
    "code": "INVALID_PARAMETER",
    "message": "Invalid email format",
    "details": [
      {
        "field": "email",
        "message": "Must be a valid email address"
      }
    ],
    "requestId": "request-123456",
    "timestamp": "2023-09-15T14:30:00Z"
  }
}
```

## HATEOAS

HATEOAS(Hypermedia as the Engine of Application State)는 클라이언트가 리소스와 관련된 작업을 동적으로 발견할 수 있게 합니다.

### 링크 제공 예시

```json
{
  "id": 123,
  "name": "John Doe",
  "email": "john@example.com",
  "_links": {
    "self": { "href": "/users/123" },
    "orders": { "href": "/users/123/orders" },
    "update": { "href": "/users/123", "method": "PATCH" },
    "delete": { "href": "/users/123", "method": "DELETE" }
  }
}
```

## 캐싱

캐싱을 사용하여 API 성능을 최적화합니다.

### 캐싱 헤더 사용

```
// 응답 헤더
Cache-Control: max-age=3600
ETag: "33a64df551425fcc55e4d42a148795d9f25f89d4"
Last-Modified: Wed, 15 Sep 2023 14:30:00 GMT

// 조건부 요청
GET /users/123
If-None-Match: "33a64df551425fcc55e4d42a148795d9f25f89d4"
```

## 문서화

API를 명확하게 문서화하여 사용자가 쉽게 이해하고 사용할 수 있도록 합니다.

### 문서화 도구

- OpenAPI (Swagger)
- API Blueprint
- Postman Documentation

### 문서 내용

- 엔드포인트 설명
- 요청 파라미터 및 바디
- 응답 형식 및 상태 코드
- 인증 방법
- 예제 코드

## 결론

RESTful API를 설계할 때는 위 가이드라인을 참고하되, 프로젝트의 특성과 요구사항에 맞게 조정하는 것이 중요합니다. 일관성을 유지하고 개발자 경험을 최우선으로 고려하여 직관적이고 사용하기 쉬운 API를 설계해야 합니다.

# 백엔드 API 설계 컨벤션

## 개요

이 문서는 백엔드 시스템의 API 설계에 관한 코딩 컨벤션을 정의합니다. RESTful API 설계 원칙, URL 구조, HTTP 메서드 사용법, 요청/응답 형식, 상태 코드 등에 대한 일관된 규칙을 통해 사용하기 쉽고 유지보수가 용이한 API를 구축하는 것을 목표로 합니다.

## RESTful API 설계 원칙

### 기본 원칙
- 리소스 중심으로 API 설계 (명사 사용)
- HTTP 메서드로 행위 표현 (GET, POST, PUT, DELETE 등)
- 상태를 저장하지 않는 무상태(Stateless) 설계
- 계층화된 시스템 구조
- 균일한 인터페이스 제공

### 리소스 명명 규칙
- 리소스는 **명사**와 **복수형**으로 표현
- URL은 소문자로 작성
- 단어 구분은 하이픈(`-`) 사용 (스네이크 케이스, 카멜 케이스 지양)

```
# 좋은 예
GET /api/v1/users
GET /api/v1/user-profiles
GET /api/v1/shopping-carts/123

# 나쁜 예
GET /api/v1/getUsers
GET /api/v1/user_profiles
GET /api/v1/ShoppingCart/123
```

## URL 구조 설계

### 기본 URL 구조
```
/api/{version}/{resources}/{identifier}/{sub-resources}
```

### 예시
```
# 모든 사용자 목록 조회
GET /api/v1/users

# 특정 사용자 조회
GET /api/v1/users/123

# 특정 사용자의 주문 목록 조회
GET /api/v1/users/123/orders

# 특정 사용자의 특정 주문 조회
GET /api/v1/users/123/orders/456
```

### 쿼리 파라미터 사용
- 필터링, 정렬, 페이징 등에는 쿼리 파라미터 사용

```
# 필터링
GET /api/v1/products?category=electronics

# 정렬
GET /api/v1/products?sort=price-asc

# 페이징
GET /api/v1/products?page=1&size=10

# 복합 쿼리 파라미터
GET /api/v1/products?category=electronics&sort=price-asc&page=1&size=10
```

## HTTP 메서드 사용 가이드

### 메서드별 사용 목적
- **GET**: 리소스 조회 (읽기 전용, 멱등성)
- **POST**: 리소스 생성
- **PUT**: 리소스 전체 수정 (멱등성)
- **PATCH**: 리소스 부분 수정
- **DELETE**: 리소스 삭제 (멱등성)

### 예시
```
# 사용자 목록 조회
GET /api/v1/users

# 새 사용자 생성
POST /api/v1/users

# 사용자 정보 전체 수정
PUT /api/v1/users/123

# 사용자 정보 일부 수정
PATCH /api/v1/users/123

# 사용자 삭제
DELETE /api/v1/users/123
```

### 컨트롤러 메소드 명명 규칙
```java
@RestController
@RequestMapping("/v1/users")
public class UserController {
    // 목록 조회
    @GetMapping
    public List<UserResponseDto> getUsers() { ... }
    
    // 단일 조회
    @GetMapping("/{id}")
    public UserResponseDto getUser(@PathVariable Long id) { ... }
    
    // 생성
    @PostMapping
    public UserResponseDto createUser(@RequestBody UserCreateDto request) { ... }
    
    // 전체 수정
    @PutMapping("/{id}")
    public UserResponseDto updateUser(@PathVariable Long id, @RequestBody UserUpdateDto request) { ... }
    
    // 부분 수정
    @PatchMapping("/{id}")
    public UserResponseDto partialUpdateUser(@PathVariable Long id, @RequestBody UserPatchDto request) { ... }
    
    // 삭제
    @DeleteMapping("/{id}")
    public void deleteUser(@PathVariable Long id) { ... }
}
```

## 요청 및 응답 형식 표준화

### 기본 요청 형식
- Content-Type: `application/json`
- 요청 본문은 리소스의 속성을 JSON 객체로 표현
- 중첩된 객체 구조 대신 단순한 구조 지향

```json
// POST /api/v1/users
{
  "email": "user@example.com",
  "name": "홍길동",
  "password": "securePassword123",
  "birthDate": "1990-01-01"
}
```

### 기본 응답 형식
- 일관된 응답 구조 사용
- 성공/실패 여부, 데이터, 에러 메시지 등 포함

```json
// 성공 응답
{
  "success": true,
  "data": {
    "id": 123,
    "email": "user@example.com",
    "name": "홍길동",
    "createdAt": "2023-01-01T12:00:00Z"
  }
}

// 목록 응답
{
  "success": true,
  "data": {
    "content": [
      { "id": 1, "name": "Product 1" },
      { "id": 2, "name": "Product 2" }
    ],
    "page": 0,
    "size": 10,
    "totalElements": 42,
    "totalPages": 5
  }
}

// 실패 응답
{
  "success": false,
  "error": {
    "code": "USER_NOT_FOUND",
    "message": "사용자를 찾을 수 없습니다.",
    "details": {
      "id": 999
    }
  }
}
```

### 응답 래퍼 클래스
```java
@Getter
public class ApiResponse<T> {
    private final boolean success;
    private final T data;
    private final ErrorResponse error;
    
    private ApiResponse(boolean success, T data, ErrorResponse error) {
        this.success = success;
        this.data = data;
        this.error = error;
    }
    
    public static <T> ApiResponse<T> success(T data) {
        return new ApiResponse<>(true, data, null);
    }
    
    public static <T> ApiResponse<T> error(ErrorResponse error) {
        return new ApiResponse<>(false, null, error);
    }
}

@Getter
public class ErrorResponse {
    private final String code;
    private final String message;
    private final Map<String, Object> details;
    
    private ErrorResponse(String code, String message, Map<String, Object> details) {
        this.code = code;
        this.message = message;
        this.details = details;
    }
    
    public static ErrorResponse of(String code, String message) {
        return new ErrorResponse(code, message, Collections.emptyMap());
    }
    
    public static ErrorResponse of(String code, String message, Map<String, Object> details) {
        return new ErrorResponse(code, message, details);
    }
}

@Getter
public class PageResponse<T> {
    private final List<T> content;
    private final int page;
    private final int size;
    private final long totalElements;
    private final int totalPages;
    
    // 생성자, 팩토리 메소드 등
}
```

## HTTP 상태 코드 사용 가이드

### 기본 상태 코드
- **2xx**: 성공
  - 200 OK: 요청 성공 (GET, PUT, PATCH)
  - 201 Created: 리소스 생성 성공 (POST)
  - 204 No Content: 성공했지만 응답 본문 없음 (DELETE)
- **4xx**: 클라이언트 오류
  - 400 Bad Request: 잘못된 요청 구문, 유효하지 않은 파라미터
  - 401 Unauthorized: 인증 필요
  - 403 Forbidden: 권한 부족
  - 404 Not Found: 리소스를 찾을 수 없음
  - 409 Conflict: 리소스 상태 충돌
  - 422 Unprocessable Entity: 유효성 검증 실패
- **5xx**: 서버 오류
  - 500 Internal Server Error: 서버 내부 오류

### 컨트롤러에서의 응답 코드 설정
```java
@RestController
@RequestMapping("/v1/users")
public class UserController {
    @PostMapping
    public ResponseEntity<ApiResponse<UserResponseDto>> createUser(@RequestBody @Valid UserCreateDto request) {
        UserResponseDto user = userService.createUser(request);
        return ResponseEntity.status(HttpStatus.CREATED)
                            .body(ApiResponse.success(user));
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<UserResponseDto>> getUser(@PathVariable Long id) {
        UserResponseDto user = userService.findById(id);
        return ResponseEntity.ok(ApiResponse.success(user));
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteUser(@PathVariable Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

## 글로벌 예외 처리

### @RestControllerAdvice 활용
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiResponse<Void>> handleEntityNotFoundException(EntityNotFoundException e) {
        ErrorResponse error = ErrorResponse.of("RESOURCE_NOT_FOUND", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                            .body(ApiResponse.error(error));
    }
    
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiResponse<Void>> handleValidationExceptions(MethodArgumentNotValidException e) {
        Map<String, Object> details = new HashMap<>();
        e.getBindingResult().getFieldErrors().forEach(error -> 
            details.put(error.getField(), error.getDefaultMessage()));
        
        ErrorResponse error = ErrorResponse.of("VALIDATION_FAILED", "유효성 검증에 실패했습니다.", details);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
                            .body(ApiResponse.error(error));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiResponse<Void>> handleAllExceptions(Exception e) {
        ErrorResponse error = ErrorResponse.of("INTERNAL_SERVER_ERROR", "서버 내부 오류가 발생했습니다.");
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                            .body(ApiResponse.error(error));
    }
}
```

## 버전 관리 전략

### URI 버전 관리
URL 경로에 버전 정보를 포함하는 방식을 기본으로 사용합니다.

```
/api/v1/users
/api/v2/users
```

### 컨트롤러 구성
```java
@RestController
@RequestMapping("/v1/users")
public class UserControllerV1 {
    // V1 API 구현
}

@RestController
@RequestMapping("/v2/users")
public class UserControllerV2 {
    // V2 API 구현
}
```

### 버전 관리 가이드
- 하위 호환성이 깨지는 변경사항이 있을 때만 메이저 버전 업그레이드
- 가능한 한 API의 확장성을 고려하여 설계하여 버전 변경 최소화
- 신규 버전 출시 시 이전 버전에 대한 지원 정책 명시 (deprecated 표시 및 지원 종료 일정)

## 페이징, 정렬, 필터링 처리

### 페이징 처리
```
GET /api/v1/products?page=0&size=10
```

### 정렬 처리
```
GET /api/v1/products?sort=price,asc&sort=name,desc
```

### 필터링 처리
```
GET /api/v1/products?category=electronics&minPrice=100&maxPrice=500
```

### 컨트롤러 구현
```java
@RestController
@RequestMapping("/v1/products")
public class ProductController {
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<ProductResponseDto>>> getProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size,
            @RequestParam(required = false) String category,
            @RequestParam(required = false) BigDecimal minPrice,
            @RequestParam(required = false) BigDecimal maxPrice,
            @RequestParam(defaultValue = "id,desc") String[] sort) {
        
        Pageable pageable = createPageable(page, size, sort);
        ProductSearchCriteria criteria = new ProductSearchCriteria(category, minPrice, maxPrice);
        
        PageResponse<ProductResponseDto> response = productService.findProducts(criteria, pageable);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    private Pageable createPageable(int page, int size, String[] sort) {
        List<Sort.Order> orders = Arrays.stream(sort)
            .map(this::createOrder)
            .collect(Collectors.toList());
        
        return PageRequest.of(page, size, Sort.by(orders));
    }
    
    private Sort.Order createOrder(String sort) {
        String[] parts = sort.split(",");
        String property = parts[0];
        
        if (parts.length == 1) {
            return Sort.Order.asc(property);
        }
        
        return "desc".equalsIgnoreCase(parts[1]) 
            ? Sort.Order.desc(property) 
            : Sort.Order.asc(property);
    }
}
```

## API 문서화

### Springdoc-OpenAPI (Swagger) 활용
```java
@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("My Service API")
                        .version("1.0")
                        .description("My Service API 문서")
                        .contact(new Contact()
                                .name("개발팀")
                                .email("dev@example.com")))
                .servers(List.of(
                        new Server().url("https://api.example.com").description("운영 서버"),
                        new Server().url("https://staging-api.example.com").description("스테이징 서버"),
                        new Server().url("http://localhost:8080").description("로컬 서버")
                ));
    }
}
```

### 컨트롤러 문서화
```java
@RestController
@RequestMapping("/v1/users")
@Tag(name = "사용자 API", description = "사용자 정보 관리 API")
public class UserController {
    @Operation(
        summary = "사용자 생성",
        description = "새로운 사용자를 생성합니다."
    )
    @ApiResponses({
        @ApiResponse(responseCode = "201", description = "사용자 생성 성공"),
        @ApiResponse(responseCode = "400", description = "잘못된 요청"),
        @ApiResponse(responseCode = "409", description = "이미 존재하는 이메일")
    })
    @PostMapping
    public ResponseEntity<ApiResponse<UserResponseDto>> createUser(
            @RequestBody @Valid UserCreateDto request) {
        // ...
    }
    
    @Operation(
        summary = "사용자 조회",
        description = "ID로 사용자를 조회합니다."
    )
    @GetMapping("/{id}")
    public ResponseEntity<ApiResponse<UserResponseDto>> getUser(
            @Parameter(description = "사용자 ID") @PathVariable Long id) {
        // ...
    }
}
```

### 요청/응답 모델 문서화
```java
@Schema(description = "사용자 생성 요청")
@Getter
public class UserCreateDto {
    @Schema(description = "이메일", example = "user@example.com")
    @NotBlank(message = "이메일은 필수입니다.")
    @Email(message = "유효한 이메일 형식이 아닙니다.")
    private String email;
    
    @Schema(description = "이름", example = "홍길동")
    @NotBlank(message = "이름은 필수입니다.")
    @Size(min = 2, max = 50, message = "이름은 2-50자 사이여야 합니다.")
    private String name;
    
    @Schema(description = "비밀번호", example = "securePassword123")
    @NotBlank(message = "비밀번호는 필수입니다.")
    @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
             message = "비밀번호는 최소 8자, 하나 이상의 문자와 숫자를 포함해야 합니다.")
    private String password;
}
```

## 인증 및 인가

### JWT 기반 인증
```
# 인증 요청
POST /api/v1/auth/login
{
  "email": "user@example.com",
  "password": "password123"
}

# 응답
{
  "success": true,
  "data": {
    "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expiresIn": 3600
  }
}

# 인증된 요청
GET /api/v1/users/me
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### 권한 제어
```java
@RestController
@RequestMapping("/v1/admin")
public class AdminController {
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    @GetMapping("/users")
    public ResponseEntity<ApiResponse<List<UserResponseDto>>> getAllUsers() {
        // ...
    }
    
    @PreAuthorize("hasAnyRole('ROLE_ADMIN', 'ROLE_MANAGER')")
    @GetMapping("/products")
    public ResponseEntity<ApiResponse<List<ProductResponseDto>>> getAllProducts() {
        // ...
    }
}
```

## 보안 관련 가이드라인

### 기본 보안 원칙
- 모든 API 엔드포인트는 인증 및 인가 처리
- HTTPS 사용 강제화
- API 요청 제한(Rate Limiting) 구현
- 민감한 정보는 응답에 포함하지 않음

### 입력 값 검증
모든 API 요청 데이터는 철저한 유효성 검증 수행

```java
@PostMapping("/users")
public ResponseEntity<ApiResponse<UserResponseDto>> createUser(
        @RequestBody @Valid UserCreateDto request) {
    // @Valid 어노테이션으로 자동 유효성 검증
    // ...
}

@Getter
public class UserCreateDto {
    @NotBlank(message = "이메일은 필수입니다.")
    @Email(message = "유효한 이메일 형식이 아닙니다.")
    private String email;
    
    @NotBlank(message = "이름은 필수입니다.")
    @Size(min = 2, max = 50, message = "이름은 2-50자 사이여야 합니다.")
    private String name;
    
    @NotBlank(message = "비밀번호는 필수입니다.")
    @Pattern(regexp = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$",
             message = "비밀번호는 최소 8자, 하나 이상의 문자와 숫자를 포함해야 합니다.")
    private String password;
    
    // DTO는 필요시 추가 유효성 검증 로직 포함 가능
    public void validate() {
        // 추가 검증 로직
    }
}
```

### CORS 설정
```java
@Configuration
public class WebConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins("https://frontend.example.com")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

## API 디자인 체크리스트

API 설계를 완료한 후 아래 체크리스트를 통해 검증합니다:

1. API가 RESTful 원칙을 준수하는가?
2. URL 구조가 직관적이고 일관성이 있는가?
3. HTTP 메서드를 올바르게 사용했는가?
4. 응답 구조가 명확하고 일관성이 있는가?
5. 적절한 HTTP 상태 코드를 사용했는가?
6. 오류 처리 및 예외 처리가 명확한가?
7. API 문서화가 충분히 되어 있는가?
8. 인증 및 권한 체크가 적절히 구현되었는가?
9. 입력 값 검증이 충분한가?
10. 페이징, 정렬, 필터링 등의 기능이 필요한 경우 적절히 구현되었는가?

## 참고 문헌

- [RESTful Web Services Cookbook](mdc:https:/www.oreilly.com/library/view/restful-web-services/9780596809140)
- [Spring REST Docs](mdc:https:/spring.io/projects/spring-restdocs)
- [Springdoc-OpenAPI](mdc:https:/springdoc.org)
- [Microsoft REST API Guidelines](mdc:https:/github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md)
