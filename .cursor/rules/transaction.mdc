---
description: Comprehensive backend transaction management conventions using Spring Framework. Covers ACID principles, @Transactional annotation usage, propagation properties, isolation levels, rollback policies, read-only optimizations, and transaction boundary settings. Includes best practices for maintaining data consistency, optimizing performance, and implementing reliable transaction management in service-oriented architectures.
globs: 
alwaysApply: false
---
# 백엔드 트랜잭션 관리 컨벤션

## 개요

이 문서는 백엔드 시스템의 트랜잭션 관리에 관한 코딩 컨벤션을 정의합니다. Spring 프레임워크의 트랜잭션 관리 기능을 활용하여 데이터 일관성을 유지하고 안정적인 서비스를 구현하는 방법을 설명합니다.

## 트랜잭션 기본 원칙

### ACID 속성 이해
- **원자성(Atomicity)**: 트랜잭션 내 모든 연산은 전부 성공하거나 전부 실패해야 함
- **일관성(Consistency)**: 트랜잭션 전후로 데이터베이스는 일관된 상태를 유지해야 함
- **격리성(Isolation)**: 동시에 실행되는 트랜잭션은 서로 영향을 주지 않아야 함
- **지속성(Durability)**: 성공적으로 완료된 트랜잭션의 결과는 영구적으로 반영되어야 함

### 설계 원칙
- 트랜잭션은 가능한 짧게 유지
- 트랜잭션 내에서 외부 API 호출 지양
- 논리적으로 하나의 작업 단위를 하나의 트랜잭션으로 처리
- 읽기 전용 작업은 명시적으로 readOnly 설정

## @Transactional 어노테이션 사용 가이드

### 기본 사용법
```java
@Service
public class OrderService {
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 트랜잭션 내에서 수행될 비즈니스 로직
        // ...
        return savedOrder;
    }
    
    @Transactional(readOnly = true)
    public Order findOrderById(Long id) {
        // 읽기 전용 트랜잭션
        // ...
        return order;
    }
}
```

### 적용 위치
- **클래스 레벨**: 클래스의 모든 public 메소드에 트랜잭션 적용 (트랜잭션은 가능한 짧게 유지해야 하므로 이 사용은 지양한다.)
- **메소드 레벨**: 특정 메소드에만 트랜잭션 적용 (메소드 레벨이 클래스 레벨보다 우선순위 높음)

```java
@Service
@Transactional  // 클래스 레벨 적용 - 모든 public 메소드에 적용 -> Bad
public class UserService {
    // 클래스 레벨 설정 상속
    public User createUser(UserRequest request) {
        // ...
    }
    
    // 메소드 레벨 설정이 클래스 레벨보다 우선 -> Good
    @Transactional(readOnly = true)
    public User findById(Long id) {
        // ...
    }
    
    // 트랜잭션 제외
    @Transactional(propagation = Propagation.NEVER)
    public void someNonTransactionalOperation() {
        // ...
    }
}
```

### 명명 규칙
- 트랜잭션이 필요한 메소드는 다음과 같은 prefix를 사용하는 것이 권장됨
  - `create*`, `add*`, `save*`, `update*`, `delete*`, `remove*`, `process*` 등
- 읽기 전용 트랜잭션은 다음과 같은 prefix를 사용
  - `get*`, `find*`, `search*`, `list*`, `count*` 등

## 트랜잭션 전파 속성(Propagation)

### 주요 전파 속성 설정
```java
@Service
public class OrderService {
    // 기본값 - 트랜잭션이 있으면 참여, 없으면 새로 생성
    @Transactional(propagation = Propagation.REQUIRED)
    public void method1() { ... }
    
    // 항상 새로운 트랜잭션 생성
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void method2() { ... }
    
    // 트랜잭션이 있으면 참여, 없으면 트랜잭션 없이 실행
    @Transactional(propagation = Propagation.SUPPORTS)
    public void method3() { ... }
    
    // 트랜잭션 없이 실행, 트랜잭션이 있으면 예외 발생
    @Transactional(propagation = Propagation.NEVER)
    public void method4() { ... }
    
    // 트랜잭션 내에서 실행, 없으면 예외 발생
    @Transactional(propagation = Propagation.MANDATORY)
    public void method5() { ... }
    
    // 트랜잭션이 있으면 트랜잭션 없이 실행, 없으면 트랜잭션 없이 실행
    @Transactional(propagation = Propagation.NOT_SUPPORTED)
    public void method6() { ... }
    
    // 독립적인 트랜잭션에서 실행 (내부 트랜잭션 실패시 외부 트랜잭션 영향 없음)
    @Transactional(propagation = Propagation.NESTED)
    public void method7() { ... }
}
```

### 전파 속성 사용 가이드
- **REQUIRED**: 대부분의 서비스 메소드에 적합 (기본값)
- **REQUIRES_NEW**: 독립적인 트랜잭션이 필요한 경우 (현재 트랜잭션과 무관하게 항상 커밋/롤백)
- **NESTED**: 외부 트랜잭션 유지하면서 현재 작업만 롤백 가능한 경우 (JPA에서는 제한적 지원)
- **SUPPORTS**: 트랜잭션이 있으면 좋지만 필수는 아닌 경우
- **MANDATORY**: 반드시 트랜잭션 내에서만 실행되어야 하는 경우
- **NEVER, NOT_SUPPORTED**: 트랜잭션 없이 실행되어야 하는 경우

## 격리 수준(Isolation)

### 격리 수준 설정
```java
@Service
public class ProductService {
    // 기본 격리 수준 (DB 기본 설정 사용)
    @Transactional(isolation = Isolation.DEFAULT)
    public void method1() { ... }
    
    // 커밋된 데이터만 읽기 가능
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public void method2() { ... }
    
    // 트랜잭션 시작 시점의 스냅샷 읽기 (팬텀 리드 방지)
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void method3() { ... }
    
    // 완전한 격리 (가장 엄격하지만 성능 저하 가능성)
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void method4() { ... }
    
    // 커밋되지 않은 데이터도 읽기 가능 (일반적으로 사용 지양)
    @Transactional(isolation = Isolation.READ_UNCOMMITTED)
    public void method5() { ... }
}
```

### 격리 수준 선택 가이드
- **READ_COMMITTED**: 일반적인 웹 애플리케이션에 적합 (Oracle, PostgreSQL 기본값)
- **REPEATABLE_READ**: 동일 트랜잭션 내에서 일관된 데이터 조회가 필요한 경우 (MySQL 기본값)
- **SERIALIZABLE**: 데이터 무결성이 매우 중요한 경우 (성능 저하가 발생할 수 있음)
- **READ_UNCOMMITTED**: 테스트 환경 외에는 사용 지양

## 롤백 정책

### 예외 롤백 설정
```java
@Service
public class PaymentService {
    // 런타임 예외만 롤백 (기본값)
    @Transactional
    public void method1() { ... }
    
    // 특정 예외 클래스 발생 시 롤백
    @Transactional(rollbackFor = {CustomException.class})
    public void method2() { ... }
    
    // 특정 예외 클래스 발생 시 롤백하지 않음
    @Transactional(noRollbackFor = {IgnorableException.class})
    public void method3() { ... }
    
    // 모든 예외에 대해 롤백
    @Transactional(rollbackFor = Exception.class)
    public void method4() { ... }
}
```

### 롤백 정책 가이드
- 기본적으로 `RuntimeException` 및 그 하위 예외에서만 롤백됨
- `Exception` 및 Checked Exception은 롤백되지 않으므로 `rollbackFor` 속성 사용
- 대규모 애플리케이션의 경우 일관된 예외 처리 전략 수립 필요

## 읽기 전용 트랜잭션 최적화

### readOnly 속성 활용
```java
@Service
public class ProductService {
    // 읽기 전용 트랜잭션
    @Transactional(readOnly = true)
    public List<Product> findAllProducts() {
        return productRepository.findAll();
    }
    
    // 읽기/쓰기 트랜잭션
    @Transactional
    public Product createProduct(ProductRequest request) {
        // ...
    }
}
```

### 읽기 전용 트랜잭션 최적화 효과
- JPA/Hibernate에서 영속성 컨텍스트의 변경 감지(Dirty Checking) 비활성화
- 일부 DBMS에서 읽기 전용 트랜잭션 최적화 적용
- 데이터베이스 레벨에서 읽기 전용 트랜잭션은 쓰기 잠금을 획득하지 않아 성능 향상

### 서비스 계층 설계 패턴
```java
// 읽기/쓰기 분리 패턴 적용
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final OrderQueryService orderQueryService;
    
    @Transactional
    public Order createOrder(OrderRequest request) {
        // 쓰기 작업
    }
    
    @Transactional
    public void cancelOrder(Long orderId) {
        // 쓰기 작업
    }
}

@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)  // 클래스 레벨에 읽기 전용 설정
public class OrderQueryService {
    private final OrderRepository orderRepository;
    
    public Order findById(Long id) {
        // 읽기 작업
    }
    
    public List<Order> findByUserId(Long userId) {
        // 읽기 작업
    }
}
```

## 트랜잭션 경계 설정

### 트랜잭션 경계 원칙
- 트랜잭션 경계는 서비스 계층에 설정
- 레포지토리 계층에는 트랜잭션을 적용하지 않음
- 컨트롤러 계층에는 가급적 트랜잭션을 적용하지 않음 (Open Session In View 관련 고려 필요, OSIV는 지양한다.)

```java
// 권장: 서비스 계층에 트랜잭션 적용
@Service
public class UserService {
    @Transactional
    public User createUser(UserRequest request) {
        // ...
    }
}

// 비권장: 레포지토리에 트랜잭션 적용
@Repository
public class CustomUserRepository {
    @Transactional  // 지양해야 할 패턴
    public User save(User user) {
        // ...
    }
}

// 비권장: 컨트롤러에 트랜잭션 적용
@RestController
public class UserController {
    @Transactional  // 지양해야 할 패턴
    @PostMapping("/users")
    public UserResponse createUser(@RequestBody UserRequest request) {
        // ...
    }
}
```

### 트랜잭션 범위 최적화
- 트랜잭션은 필요한 최소한의 작업만 포함하도록 설계
- 트랜잭션 내에서 외부 API 호출이나 긴 연산은 피함
- 대용량 작업은 배치 처리나 청크 단위로 나누어 처리

```java
@Service
@RequiredArgsConstructor
public class OrderService {
    private final OrderRepository orderRepository;
    private final PaymentClient paymentClient;  // 외부 API
    
    // Bad: 트랜잭션 내에서 외부 API 호출
    @Transactional
    public Order createOrderBad(OrderRequest request) {
        Order order = orderRepository.save(new Order(request));
        // 외부 API 호출 - 트랜잭션이 오래 유지될 수 있음
        paymentClient.processPayment(order.getId(), request.getPaymentInfo());
        return order;
    }
    
    // Good: 트랜잭션 분리
    public Order createOrderGood(OrderRequest request) {
        // 1. 주문 생성 트랜잭션
        Order order = createOrderInternal(request);
        
        // 2. 트랜잭션 외부에서 외부 API 호출
        PaymentResult result = paymentClient.processPayment(
            order.getId(), request.getPaymentInfo());
        
        // 3. 결제 결과 업데이트 트랜잭션
        updatePaymentResult(order.getId(), result);
        
        return orderRepository.findById(order.getId()).orElseThrow();
    }
    
    @Transactional
    protected Order createOrderInternal(OrderRequest request) {
        return orderRepository.save(new Order(request));
    }
    
    @Transactional
    protected void updatePaymentResult(Long orderId, PaymentResult result) {
        Order order = orderRepository.findById(orderId).orElseThrow();
        order.updatePaymentStatus(result.getStatus());
    }
}
```


## 참고 문헌

- [Spring Transaction Management](mdc:https:/docs.spring.io/spring-framework/docs/current/reference/html/data-access.html#transaction)
- [Hibernate ORM Documentation](mdc:https:/docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html)
- [Implementing Domain-Driven Design](mdc:https:/www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)
