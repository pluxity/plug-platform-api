---
description: Comprehensive query optimization guidelines for backend systems using JPA, JPQL, and QueryDSL. Covers efficient query writing techniques, N+1 problem solutions, dynamic query construction, pagination strategies, bulk operations, caching mechanisms, performance monitoring, and execution plan analysis to improve response times and optimize server resource usage.
globs: 
alwaysApply: false
---
# 백엔드 쿼리 최적화 컨벤션

## 개요

이 문서는 백엔드 시스템의 쿼리 최적화에 관한 코딩 컨벤션을 정의합니다. JPA, JPQL, QueryDSL 등을 활용한 효율적인 쿼리 작성법과 성능 최적화 전략을 통해 응답 시간을 개선하고 서버 자원을 효율적으로 사용하는 것을 목표로 합니다.

## JPQL 작성 규칙

### 기본 원칙
- JPQL은 필요한 데이터만 조회하도록 작성 (항상 `SELECT *` 지양)
- 문자열 연결로 동적 쿼리 생성 금지 (SQL 인젝션 위험)
- 복잡한 쿼리는 네이티브 쿼리보다 QueryDSL 사용 권장
- 쿼리 가독성을 위해 Java 15+ 텍스트 블록(`"""`) 활용

```java
// Bad - String 연결
@Query("SELECT p FROM Product p WHERE p.category.id = " + categoryId)
List<Product> findProductsByCategoryId(Long categoryId);

// Good - 파라미터 바인딩
@Query("SELECT p FROM Product p WHERE p.category.id = :categoryId")
List<Product> findProductsByCategoryId(@Param("categoryId") Long categoryId);

// Better - 텍스트 블록 활용
@Query("""
    SELECT p FROM Product p
    WHERE p.category.id = :categoryId
    ORDER BY p.name
""")
List<Product> findProductsByCategoryId(@Param("categoryId") Long categoryId);
```

### 필요한 컬럼만 조회
전체 엔티티가 필요하지 않은 경우 DTO 프로젝션을 활용합니다.

```java
// Bad - 전체 엔티티 조회
@Query("SELECT p FROM Product p WHERE p.category.id = :categoryId")
List<Product> findProductsByCategoryId(@Param("categoryId") Long categoryId);

// Good - 필요한 필드만 DTO로 조회
@Query("""
    SELECT new com.example.dto.ProductSummaryDto(
        p.id, p.name, p.price, p.stockQuantity
    )
    FROM Product p
    WHERE p.category.id = :categoryId
""")
List<ProductSummaryDto> findProductSummaryByCategoryId(@Param("categoryId") Long categoryId);
```

## N+1 문제 해결 전략

### 페치 조인(Fetch Join)
연관된 엔티티를 함께 조회하여 N+1 문제를 해결합니다.

```java
// Bad - N+1 문제 발생
@Query("SELECT o FROM Order o WHERE o.status = :status")
List<Order> findByStatus(@Param("status") OrderStatus status);

// Good - 페치 조인으로 해결
@Query("""
    SELECT o FROM Order o
    JOIN FETCH o.user
    LEFT JOIN FETCH o.orderItems
    WHERE o.status = :status
""")
List<Order> findByStatusWithUserAndItems(@Param("status") OrderStatus status);
```

### 페치 조인 사용 시 주의사항
- 둘 이상의 컬렉션을 페치 조인할 수 없음
- 페치 조인과 페이징을 함께 사용할 때 주의 필요 (메모리에서 페이징 처리 위험)

```java
// 위험 - 컬렉션 페치 조인 + 페이징
@Query("""
    SELECT o FROM Order o
    JOIN FETCH o.orderItems
    WHERE o.status = :status
""")
Page<Order> findByStatus(@Param("status") OrderStatus status, Pageable pageable);  // 주의 필요!

// 해결책 1 - ToOne 관계만 페치 조인 + 페이징
@Query("""
    SELECT o FROM Order o
    JOIN FETCH o.user
    WHERE o.status = :status
""")
Page<Order> findByStatusWithUser(@Param("status") OrderStatus status, Pageable pageable);

// 해결책 2 - ID 조회 후 IN 절로 벌크 조회
@Query(value = "SELECT o.id FROM Order o WHERE o.status = :status",
       countQuery = "SELECT COUNT(o) FROM Order o WHERE o.status = :status")
Page<Long> findOrderIdsByStatus(@Param("status") OrderStatus status, Pageable pageable);

@Query("""
    SELECT o FROM Order o
    JOIN FETCH o.user
    LEFT JOIN FETCH o.orderItems
    WHERE o.id IN :ids
""")
List<Order> findByIdsWithUserAndItems(@Param("ids") List<Long> ids);
```

### EntityGraph 활용
간단한 페치 조인이 필요할 때는 `@EntityGraph`를 활용합니다.

```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    // attributePaths에 함께 조회할 연관 엔티티 지정
    @EntityGraph(attributePaths = {"user", "orderItems"})
    List<Order> findByStatus(OrderStatus status);
    
    // 동적으로 EntityGraph 생성
    @EntityGraph(attributePaths = {"user"})
    List<Order> findByUserId(Long userId);
}
```

### 배치 사이즈 설정
연관된 엔티티를 효율적으로 로딩하기 위한 배치 사이즈를 설정합니다.

```java
// 엔티티 레벨 설정
@Entity
@Table(name = "orders")
public class Order {
    // ...
    
    @BatchSize(size = 100)
    @OneToMany(mappedBy = "order")
    private List<OrderItem> orderItems = new ArrayList<>();
}

// 글로벌 설정 (application.yml)
spring:
  jpa:
    properties:
      hibernate:
        default_batch_fetch_size: 100
```

## QueryDSL 활용

### 동적 쿼리 작성
조건에 따라 동적으로 쿼리를 구성할 때는 QueryDSL을 활용합니다.

```java
@Repository
@RequiredArgsConstructor
public class ProductQueryRepository {
    private final JPAQueryFactory queryFactory;
    
    // 동적 검색 조건을 반영한 조회 메소드
    public List<Product> findBySearchCondition(ProductSearchCondition condition) {
        return queryFactory
            .select(product)
            .from(product)
            .leftJoin(product.category, category).fetchJoin()
            .where(
                nameContains(condition.getName()),
                categoryEq(condition.getCategoryId()),
                priceGoe(condition.getMinPrice()),
                priceLoe(condition.getMaxPrice())
            )
            .orderBy(product.name.asc())
            .fetch();
    }
    
    // 동적 조건을 메소드로 분리
    private BooleanExpression nameContains(String name) {
        return name != null ? product.name.contains(name) : null;
    }
    
    private BooleanExpression categoryEq(Long categoryId) {
        return categoryId != null ? product.category.id.eq(categoryId) : null;
    }
    
    private BooleanExpression priceGoe(BigDecimal minPrice) {
        return minPrice != null ? product.price.goe(minPrice) : null;
    }
    
    private BooleanExpression priceLoe(BigDecimal maxPrice) {
        return maxPrice != null ? product.price.loe(maxPrice) : null;
    }
}
```

### 페이징 처리
QueryDSL을 사용한 효율적인 페이징 처리 방법입니다.

```java
@Repository
@RequiredArgsConstructor
public class ProductQueryRepository {
    private final JPAQueryFactory queryFactory;
    
    public Page<Product> findBySearchCondition(ProductSearchCondition condition, Pageable pageable) {
        // 데이터 조회
        List<Product> content = queryFactory
            .select(product)
            .from(product)
            .where(
                nameContains(condition.getName()),
                categoryEq(condition.getCategoryId())
            )
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .orderBy(getOrderSpecifier(pageable))
            .fetch();
        
        // 전체 개수 조회
        long total = queryFactory
            .select(product.count())
            .from(product)
            .where(
                nameContains(condition.getName()),
                categoryEq(condition.getCategoryId())
            )
            .fetchOne();
        
        return new PageImpl<>(content, pageable, total);
    }
    
    // 동적 정렬 처리
    private OrderSpecifier[] getOrderSpecifier(Pageable pageable) {
        // Sort 객체에서 OrderSpecifier 배열 생성 로직
        // ...
    }
}
```

### Projections 활용
필요한 필드만 선택적으로 조회하여 성능을 향상시킵니다.

```java
@Repository
@RequiredArgsConstructor
public class ProductQueryRepository {
    private final JPAQueryFactory queryFactory;
    
    // 필요한 필드만 DTO로 조회
    public List<ProductSummaryDto> findProductSummaries(Long categoryId) {
        return queryFactory
            .select(Projections.constructor(
                ProductSummaryDto.class,
                product.id,
                product.name,
                product.price,
                product.stockQuantity
            ))
            .from(product)
            .where(product.category.id.eq(categoryId))
            .fetch();
    }
    
    // QBean 방식 활용
    public List<ProductSummaryDto> findProductSummariesQBean(Long categoryId) {
        return queryFactory
            .select(Projections.bean(
                ProductSummaryDto.class,
                product.id,
                product.name,
                product.price.as("price"),
                product.stockQuantity
            ))
            .from(product)
            .where(product.category.id.eq(categoryId))
            .fetch();
    }
}
```

## 벌크 연산 최적화

### 대량 데이터 수정/삭제
대량의 데이터를 수정하거나 삭제할 때는 벌크 연산을 활용합니다.

```java
@Repository
@RequiredArgsConstructor
public class ProductRepository {
    private final EntityManager em;
    
    // JPQL 벌크 연산
    @Transactional
    public int bulkUpdatePriceByCategory(Long categoryId, BigDecimal priceIncreaseRate) {
        int updatedCount = em.createQuery("""
            UPDATE Product p
            SET p.price = p.price * :rate
            WHERE p.category.id = :categoryId
        """)
        .setParameter("rate", priceIncreaseRate)
        .setParameter("categoryId", categoryId)
        .executeUpdate();
        
        // 영속성 컨텍스트 초기화
        em.clear();
        
        return updatedCount;
    }
    
    // QueryDSL 벌크 연산
    @Transactional
    public long bulkDeleteInactiveProducts(LocalDateTime lastActiveDate) {
        long deletedCount = queryFactory
            .delete(product)
            .where(product.lastActiveDate.before(lastActiveDate))
            .execute();
        
        // 영속성 컨텍스트 초기화
        em.clear();
        
        return deletedCount;
    }
}
```

### 벌크 연산 주의사항
- 벌크 연산 후 영속성 컨텍스트 초기화 필수
- 벌크 연산은 영속성 컨텍스트를 무시하고 DB에 직접 쿼리 실행
- 가능하면 벌크 연산을 트랜잭션 시작 부분에 배치

## 페이징 처리 표준화

### 일관된 페이징 응답 포맷
페이징 결과는 일관된 형식으로 반환해야 합니다.

```java
// API 응답을 위한 페이징 공통 DTO
@Getter
public class PageResponseDto<T> {
    private List<T> content;
    private int page;
    private int size;
    private long totalElements;
    private int totalPages;
    private boolean first;
    private boolean last;
    
    // Page 객체로부터 PageResponseDto 생성
    public static <T> PageResponseDto<T> from(Page<T> page) {
        PageResponseDto<T> response = new PageResponseDto<>();
        response.content = page.getContent();
        response.page = page.getNumber();
        response.size = page.getSize();
        response.totalElements = page.getTotalElements();
        response.totalPages = page.getTotalPages();
        response.first = page.isFirst();
        response.last = page.isLast();
        return response;
    }
}
```

### 무한 스크롤 최적화
무한 스크롤이나 "더 보기" 형태의 UI에는 키셋 페이징을 활용합니다.

```java
@Repository
@RequiredArgsConstructor
public class PostQueryRepository {
    private final JPAQueryFactory queryFactory;
    
    // 일반 offset 기반 페이징
    public List<Post> findByOffsetPaging(int offset, int limit) {
        return queryFactory
            .selectFrom(post)
            .orderBy(post.createdAt.desc())
            .offset(offset)  // 성능 이슈 발생 가능
            .limit(limit)
            .fetch();
    }
    
    // 키셋 페이징 (No Offset)
    public List<Post> findByKeysetPaging(Long lastPostId, LocalDateTime lastCreatedAt, int limit) {
        return queryFactory
            .selectFrom(post)
            .where(
                lastPostIdLt(lastPostId, lastCreatedAt)
            )
            .orderBy(post.createdAt.desc(), post.id.desc())
            .limit(limit)
            .fetch();
    }
    
    // 복합 조건 생성
    private BooleanExpression lastPostIdLt(Long lastPostId, LocalDateTime lastCreatedAt) {
        if (lastPostId == null || lastCreatedAt == null) {
            return null;
        }
        
        return post.createdAt.eq(lastCreatedAt)
                .and(post.id.lt(lastPostId))
                .or(post.createdAt.lt(lastCreatedAt));
    }
}
```

## 쿼리 힌트와 락

### 쿼리 힌트 활용
필요에 따라 JPA 쿼리 힌트를 활용하여 성능을 최적화합니다.

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    // readOnly 힌트로 더티 체킹 방지
    @QueryHints(value = @QueryHint(name = "org.hibernate.readOnly", value = "true"))
    List<Product> findByCategory(Category category);
    
    // fetchSize 힌트로 대량 데이터 조회 최적화
    @QueryHints(value = @QueryHint(name = "org.hibernate.fetchSize", value = "100"))
    List<Product> findAll();
}
```

### 락 전략
동시성 제어가 필요한 경우 적절한 락 전략을 사용합니다.

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    // 비관적 락 (Pessimistic Lock)
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Product> findByIdForUpdate(Long id);
    
    // 낙관적 락 (Optimistic Lock)
    // @Version 필드가 있는 엔티티 사용
    Optional<Product> findById(Long id);
}

@Entity
@Table(name = "products")
public class Product {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // 낙관적 락을 위한 버전 필드
    @Version
    private Integer version;
    
    // 기타 필드...
}
```

## 캐싱 전략

### 스프링 캐시 활용
자주 조회되는 데이터는 캐싱하여 데이터베이스 부하를 줄입니다.

```java
@Service
@RequiredArgsConstructor
@CacheConfig(cacheNames = "products")
public class ProductService {
    private final ProductRepository productRepository;
    
    // 단일 조회 결과 캐싱
    @Cacheable(key = "#id")
    public Product findById(Long id) {
        return productRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("상품을 찾을 수 없습니다"));
    }
    
    // 수정 시 캐시 갱신
    @CachePut(key = "#product.id")
    public Product update(Product product) {
        return productRepository.save(product);
    }
    
    // 삭제 시 캐시 제거
    @CacheEvict(key = "#id")
    public void deleteById(Long id) {
        productRepository.deleteById(id);
    }
    
    // 여러 조건으로 캐싱
    @Cacheable(key = "T(java.util.Objects).hash(#categoryId, #minPrice)")
    public List<Product> findByCategoryAndPriceGreaterThan(Long categoryId, BigDecimal minPrice) {
        return productRepository.findByCategoryIdAndPriceGreaterThan(categoryId, minPrice);
    }
}
```

### 캐시 설정
애플리케이션 환경에 맞는 캐시 설정을 구성합니다.

```java
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        // 로컬 캐시 설정
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(30, TimeUnit.MINUTES)
            .maximumSize(1000));
        return cacheManager;
    }
    
    // 또는 Redis 캐시 설정
    @Bean
    public CacheManager redisCacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheManager cacheManager = RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30))
                .serializeValuesWith(
                    RedisSerializationContext.SerializationPair.fromSerializer(
                        new GenericJackson2JsonRedisSerializer()
                    )
                )
            )
            .build();
        return cacheManager;
    }
}
```

## 쿼리 성능 모니터링

### 쿼리 로깅 설정
개발 환경에서 SQL 쿼리를 모니터링할 수 있도록 설정합니다.

```yaml
# application-dev.yml
spring:
  jpa:
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
        
logging:
  level:
    org.hibernate.SQL: debug
    org.hibernate.type.descriptor.sql: trace  # 바인딩 파라미터 로깅
```

### P6Spy 활용
보다 상세한 쿼리 모니터링을 위해 P6Spy를 활용합니다.

```gradle
// build.gradle
implementation 'com.github.gavlyukovskiy:p6spy-spring-boot-starter:1.8.0'
```

```yaml
# application.yml
decorator:
  datasource:
    p6spy:
      enable-logging: true
      multiline: true
      logging: slf4j
```

## 실행 계획 분석

### 로컬 환경에서 실행 계획 확인
개발 단계에서 쿼리 실행 계획을 확인하여 성능 이슈를 사전에 파악합니다.

```java
// 테스트 코드에서 실행 계획 확인
@Test
@DisplayName("쿼리 실행 계획 확인")
void checkQueryPlan() {
    // given
    entityManager.createNativeQuery("EXPLAIN ANALYZE SELECT * FROM products WHERE category_id = 1")
        .getResultList()
        .forEach(System.out::println);
}
```

### 인덱스 활용 여부 확인
쿼리가 인덱스를 효율적으로 사용하는지 확인합니다.

```sql
-- MySQL 예시
EXPLAIN SELECT * FROM products WHERE category_id = 1;

-- PostgreSQL 예시
EXPLAIN ANALYZE SELECT * FROM products WHERE category_id = 1;
```

## 참고 문헌

- [Spring Data JPA 공식 문서](mdc:https:/docs.spring.io/spring-data/jpa/docs/current/reference/html)
- [Hibernate 성능 최적화 가이드](mdc:https:/docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html)
- [QueryDSL 레퍼런스](mdc:http:/querydsl.com/static/querydsl/latest/reference/html)
