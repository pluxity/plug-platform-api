---
description: Comprehensive backend performance optimization guidelines covering JPA query optimization, caching strategies, asynchronous processing, bulk operations, database tuning, memory management, and monitoring techniques. Includes practical patterns for solving N+1 problems, implementing effective caching, processing data in batches, utilizing async operations, and establishing performance monitoring to create efficient and scalable applications.
globs: 
alwaysApply: false
---
# 백엔드 성능 최적화 컨벤션

## 개요

이 문서는 백엔드 시스템의 성능 최적화에 관한 코딩 컨벤션을 정의합니다. JPA 쿼리 최적화, 캐싱 전략, 비동기 처리, 벌크 연산 등에 대한 일관된 가이드라인을 통해 효율적이고 확장 가능한 애플리케이션을 구현하는 것을 목표로 합니다.

## JPA 쿼리 최적화

### N+1 문제 해결

N+1 문제는 연관된 엔티티를 조회할 때 발생하는 성능 문제입니다.

#### 문제 상황
```java
// N+1 문제가 발생하는 코드
@GetMapping("/orders")
public List<OrderDto> getOrders() {
    List<Order> orders = orderRepository.findAll();  // 1번 쿼리
    
    return orders.stream()
        .map(order -> {
            // order.getItems() 호출마다 추가 쿼리 발생 (N번)
            List<OrderItem> items = order.getItems();  
            return new OrderDto(order, items);
        })
        .collect(Collectors.toList());
}
```

#### 해결 방법 1: Fetch Join 사용
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("SELECT o FROM Order o JOIN FETCH o.items")
    List<Order> findAllWithItems();
}
```

#### 해결 방법 2: EntityGraph 사용
```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    @EntityGraph(attributePaths = {"items"})
    List<Order> findAll();
}
```

#### 해결 방법 3: BatchSize 설정
```java
@Entity
public class Order {
    @OneToMany(mappedBy = "order")
    @BatchSize(size = 100)  // 한 번에 최대 100개의 연관 엔티티를 조회
    private List<OrderItem> items = new ArrayList<>();
}
```

### 페이징 처리 최적화

대량의 데이터를 조회할 때는 항상 페이징 처리를 적용합니다.

```java
// 페이징 처리 예시
@GetMapping("/products")
public Page<ProductDto> getProducts(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    
    PageRequest pageRequest = PageRequest.of(page, size, Sort.by("createdAt").descending());
    return productRepository.findAll(pageRequest).map(ProductDto::from);
}
```

### 쿼리 힌트 활용

```java
public interface ProductRepository extends JpaRepository<Product, Long> {
    @QueryHints(value = {
        @QueryHint(name = "org.hibernate.readOnly", value = "true"),
        @QueryHint(name = "org.hibernate.fetchSize", value = "50")
    })
    List<Product> findTop100ByCategory(String category);
}
```

### 프로젝션 활용

필요한 데이터만 조회하여 메모리 사용을 최적화합니다.

```java
// DTO 프로젝션 활용
public interface OrderSummaryDto {
    Long getId();
    String getOrderNumber();
    LocalDateTime getOrderDate();
    BigDecimal getTotalAmount();
}

public interface OrderRepository extends JpaRepository<Order, Long> {
    @Query("SELECT o.id as id, o.orderNumber as orderNumber, o.orderDate as orderDate, o.totalAmount as totalAmount FROM Order o")
    List<OrderSummaryDto> findAllOrderSummaries();
}
```

## 캐싱 전략

### Spring Cache 활용

자주 조회되고 변경이 적은 데이터는 캐싱을 적용합니다.

#### 캐시 설정
```java
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .expireAfterWrite(1, TimeUnit.HOURS)
                .maximumSize(100));
        return cacheManager;
    }
}
```

#### 캐시 활용
```java
@Service
@RequiredArgsConstructor
public class ProductService {
    private final ProductRepository productRepository;
    
    @Cacheable(value = "products", key = "#id")
    public Product findById(Long id) {
        return productRepository.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Product not found: " + id));
    }
    
    @CacheEvict(value = "products", key = "#product.id")
    public Product save(Product product) {
        return productRepository.save(product);
    }
    
    @CachePut(value = "products", key = "#product.id")
    public Product update(Product product) {
        return productRepository.save(product);
    }
    
    @CacheEvict(value = "products", allEntries = true)
    public void clearProductCache() {
        // 캐시 전체 삭제 메소드
    }
}
```

### Redis 캐시 활용

분산 환경에서는 Redis를 활용한 캐싱 전략을 사용합니다.

```java
@Configuration
@EnableCaching
public class RedisCacheConfig {
    @Bean
    public RedisCacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration cacheConfiguration = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(10))
                .serializeKeysWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair
                        .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(connectionFactory)
                .cacheDefaults(cacheConfiguration)
                .withCacheConfiguration("products", 
                        cacheConfiguration.entryTtl(Duration.ofHours(1)))
                .withCacheConfiguration("categories", 
                        cacheConfiguration.entryTtl(Duration.ofDays(1)))
                .build();
    }
}
```

### 캐시 키 전략

```java
@Cacheable(value = "products", key = "#root.methodName + '_' + #category + '_' + #page + '_' + #size")
public Page<Product> findByCategory(String category, int page, int size) {
    return productRepository.findByCategory(category, PageRequest.of(page, size));
}
```

## 비동기 처리

### @Async 활용

시간이 오래 걸리는 작업은 비동기로 처리합니다.

#### 비동기 설정
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    @Bean
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        executor.setThreadNamePrefix("AsyncTask-");
        executor.initialize();
        return executor;
    }
}
```

#### 비동기 메소드 구현
```java
@Service
@RequiredArgsConstructor
public class EmailService {
    private final JavaMailSender mailSender;
    private final UserRepository userRepository;
    
    @Async
    public CompletableFuture<Void> sendMarketingEmails() {
        List<User> users = userRepository.findByMarketingAgreed(true);
        
        for (User user : users) {
            try {
                // 이메일 전송 로직
                SimpleMailMessage message = new SimpleMailMessage();
                message.setTo(user.getEmail());
                message.setSubject("마케팅 정보");
                message.setText("안녕하세요, " + user.getName() + "님!");
                mailSender.send(message);
                
                // 전송 지연을 방지하기 위한 잠시 대기
                Thread.sleep(100);
            } catch (Exception e) {
                // 로깅 처리
            }
        }
        
        return CompletableFuture.completedFuture(null);
    }
}
```

### CompletableFuture 활용

여러 비동기 작업을 조합할 때는 CompletableFuture를 활용합니다.

```java
@Service
@RequiredArgsConstructor
public class ProductEnrichmentService {
    private final ProductRepository productRepository;
    private final PriceService priceService;
    private final InventoryService inventoryService;
    private final ReviewService reviewService;
    
    public CompletableFuture<ProductDetailDto> getEnrichedProduct(Long productId) {
        Product product = productRepository.findById(productId)
                .orElseThrow(() -> new EntityNotFoundException("Product not found"));
        
        CompletableFuture<PriceDto> priceFuture = 
                CompletableFuture.supplyAsync(() -> priceService.getPrice(productId));
        
        CompletableFuture<InventoryDto> inventoryFuture = 
                CompletableFuture.supplyAsync(() -> inventoryService.getInventory(productId));
        
        CompletableFuture<List<ReviewDto>> reviewsFuture = 
                CompletableFuture.supplyAsync(() -> reviewService.getTopReviews(productId));
        
        return CompletableFuture.allOf(priceFuture, inventoryFuture, reviewsFuture)
                .thenApply(v -> new ProductDetailDto(
                        product,
                        priceFuture.join(),
                        inventoryFuture.join(),
                        reviewsFuture.join()
                ));
    }
}
```

## 벌크 연산 활용

### JPA 벌크 연산

대량의 데이터를 수정/삭제할 때는 벌크 연산을 사용합니다.

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @Modifying
    @Query("UPDATE Product p SET p.price = p.price * :rate WHERE p.category = :category")
    int updatePriceByCategory(@Param("category") String category, @Param("rate") BigDecimal rate);
    
    @Modifying
    @Query("DELETE FROM Product p WHERE p.expireDate < :date")
    int deleteExpiredProducts(@Param("date") LocalDate date);
}

@Service
@RequiredArgsConstructor
public class ProductService {
    private final ProductRepository productRepository;
    
    @Transactional
    public int updateCategoryPrices(String category, BigDecimal rate) {
        int updatedCount = productRepository.updatePriceByCategory(category, rate);
        return updatedCount;
    }
}
```

### JDBC Batch 처리

JPA로 처리하기 어려운 대량 데이터 처리는 JDBC Batch를 활용합니다.

```java
@Service
@RequiredArgsConstructor
public class BulkImportService {
    private final JdbcTemplate jdbcTemplate;
    
    public void importProducts(List<ProductImportDto> products) {
        jdbcTemplate.batchUpdate(
                "INSERT INTO product (name, price, category, created_at) VALUES (?, ?, ?, ?)",
                new BatchPreparedStatementSetter() {
                    @Override
                    public void setValues(PreparedStatement ps, int i) throws SQLException {
                        ProductImportDto product = products.get(i);
                        ps.setString(1, product.getName());
                        ps.setBigDecimal(2, product.getPrice());
                        ps.setString(3, product.getCategory());
                        ps.setTimestamp(4, Timestamp.valueOf(LocalDateTime.now()));
                    }
                    
                    @Override
                    public int getBatchSize() {
                        return products.size();
                    }
                });
    }
}
```

### 청크 단위 처리

대량의 데이터를 메모리 부족 없이 처리하려면 청크 단위로 나누어 처리합니다.

```java
@Component
@RequiredArgsConstructor
public class ProductProcessor {
    private final ProductRepository productRepository;
    private final ProductEnrichmentService enrichmentService;
    
    @Transactional(readOnly = true)
    public void processAllProducts(Consumer<Product> processor) {
        int pageSize = 100;
        int page = 0;
        Page<Product> productPage;
        
        do {
            productPage = productRepository.findAll(PageRequest.of(page, pageSize));
            
            for (Product product : productPage.getContent()) {
                processor.accept(product);
            }
            
            page++;
        } while (productPage.hasNext());
    }
}
```

## 데이터베이스 최적화

### 인덱스 설계

적절한 인덱스를 통해 쿼리 성능을 향상시킵니다.

```java
@Entity
@Table(name = "orders", indexes = {
    @Index(name = "idx_orders_user_id", columnList = "user_id"),
    @Index(name = "idx_orders_order_date", columnList = "order_date"),
    @Index(name = "idx_orders_status", columnList = "status")
})
public class Order {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;
    
    @Column(name = "order_date")
    private LocalDateTime orderDate;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status")
    private OrderStatus status;
    
    // 기타 필드 및 메소드
}
```

### 느린 쿼리 로깅

성능이 좋지 않은 쿼리를 식별하고 최적화하기 위해 느린 쿼리 로깅을 설정합니다.

```properties
# application.properties (또는 application.yml)
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
spring.jpa.properties.hibernate.generate_statistics=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

### 쿼리 캐시 활용

동일한 쿼리가 자주 실행되는 경우 쿼리 캐시를 활용합니다.

```java
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    @QueryHints(value = {
        @QueryHint(name = HINT_CACHEABLE, value = "true"),
        @QueryHint(name = HINT_CACHE_REGION, value = "product_queries")
    })
    List<Product> findByCategory(String category);
}
```

## 메모리 최적화

### 페이징 처리 의무화

무제한 데이터 조회를 방지하기 위해 페이징 처리를 의무화합니다.

```java
// API 계층에서 페이징 처리 강제화
@RestController
@RequestMapping("//products")
@RequiredArgsConstructor
public class ProductController {
    private final ProductService productService;
    private final int MAX_PAGE_SIZE = 100;
    
    @GetMapping
    public Page<ProductDto> getProducts(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        
        // 최대 페이지 크기 제한
        if (size > MAX_PAGE_SIZE) {
            size = MAX_PAGE_SIZE;
        }
        
        return productService.findAll(page, size);
    }
}
```

### DTO 변환 시점 최적화

엔티티를 DTO로 변환하는 시점을 최적화합니다.

```java
// 잘못된 방식: 모든 엔티티를 메모리에 로드한 후 변환
@GetMapping("/bad-practice")
public List<UserDto> getAllUsersBadPractice() {
    List<User> users = userRepository.findAll();
    return users.stream()
            .map(UserDto::from)
            .collect(Collectors.toList());
}

// 좋은 방식: DB 수준에서 필요한 데이터만 가져와 DTO로 바로 매핑
@GetMapping("/good-practice")
public Page<UserDto> getAllUsersGoodPractice(
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size) {
    
    return userRepository.findAllUsersDto(PageRequest.of(page, size));
}

// Repository
public interface UserRepository extends JpaRepository<User, Long> {
    @Query("SELECT new com.example.dto.UserDto(u.id, u.name, u.email) FROM User u")
    Page<UserDto> findAllUsersDto(Pageable pageable);
}
```

### 즉시 로딩(Eager Loading) 제한

즉시 로딩은 필요한 경우에만 제한적으로 사용합니다.

```java
// 권장하지 않는 방식
@Entity
public class Order {
    @ManyToOne(fetch = FetchType.EAGER)  // 항상 User 엔티티를 함께 로드
    private User user;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.EAGER)  // 항상 모든 아이템을 로드
    private List<OrderItem> items;
}

// 권장하는 방식
@Entity
public class Order {
    @ManyToOne(fetch = FetchType.LAZY)  // 필요할 때만 로드
    private User user;
    
    @OneToMany(mappedBy = "order", fetch = FetchType.LAZY)  // 필요할 때만 로드
    private List<OrderItem> items;
}
```

## 로깅 및 모니터링

### AOP를 활용한 성능 모니터링

```java
@Aspect
@Component
@RequiredArgsConstructor
public class PerformanceAspect {
    private final Logger logger = LoggerFactory.getLogger(this.getClass());
    
    @Around("@annotation(com.example.annotation.LogExecutionTime)")
    public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object proceed = joinPoint.proceed();
        long executionTime = System.currentTimeMillis() - startTime;
        
        logger.info("{}#{} executed in {}ms",
                joinPoint.getSignature().getDeclaringTypeName(),
                joinPoint.getSignature().getName(),
                executionTime);
        
        return proceed;
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogExecutionTime {
}

// 사용 예시
@Service
public class ProductService {
    @LogExecutionTime
    public List<Product> findByCategory(String category) {
        // 실행 시간이 로깅되는 메소드
        return productRepository.findByCategory(category);
    }
}
```

### Actuator를 활용한 모니터링

```java
// build.gradle 또는 pom.xml에 의존성 추가
// implementation 'org.springframework.boot:spring-boot-starter-actuator'

// application.yml 설정
// management:
//   endpoints:
//     web:
//       exposure:
//         include: health,info,metrics,prometheus
//   endpoint:
//     health:
//       show-details: always
//     metrics:
//       enabled: true

@Configuration
public class ActuatorConfig {
    @Bean
    public MeterRegistryCustomizer<MeterRegistry> metricsCommonTags() {
        return registry -> registry.config().commonTags("application", "my-app");
    }
}
```

### 로그 레벨 최적화

```java
// application.yml 또는 application.properties 설정
// logging:
//   level:
//     root: INFO
//     org.springframework: WARN
//     org.hibernate: WARN
//     com.example.myapp: DEBUG

@Service
public class OrderService {
    private final Logger logger = LoggerFactory.getLogger(OrderService.class);
    
    public Order processOrder(OrderRequest request) {
        // 디버그 레벨 로그는 개발 환경에서만 출력
        logger.debug("Processing order: {}", request);
        
        try {
            // 비즈니스 로직
            Order order = createOrder(request);
            
            // 정보 레벨 로그는 운영 환경에서도 출력
            logger.info("Order processed successfully: {}", order.getId());
            
            return order;
        } catch (Exception e) {
            // 오류 레벨 로그는 항상 출력
            logger.error("Failed to process order: {}", request, e);
            throw e;
        }
    }
}
```

## 성능 최적화 체크리스트

### 데이터베이스 최적화
- [ ] N+1 문제 해결 (Fetch Join, EntityGraph, BatchSize 활용)
- [ ] 적절한 인덱스 설계 및 적용
- [ ] 필요한 데이터만 조회하는 프로젝션 활용
- [ ] 대량 데이터 조회 시 항상 페이징 처리 적용
- [ ] 벌크 연산 활용 (대량 데이터 처리)
- [ ] 읽기 전용 트랜잭션 활용 (@Transactional(readOnly = true))

### 캐싱 최적화
- [ ] 자주 조회되고 변경이 적은 데이터 캐싱
- [ ] 캐시 무효화 전략 수립
- [ ] 분산 환경에서 Redis와 같은 외부 캐시 적용
- [ ] 캐시 적중률 모니터링

### 비동기 처리
- [ ] 응답 시간에 영향을 미치지 않는 작업 비동기 처리
- [ ] 스레드 풀 크기 최적화
- [ ] CompletableFuture 활용하여 병렬 작업 처리
- [ ] 비동기 작업 오류 처리 및 재시도 전략 수립

### 메모리 최적화
- [ ] 무제한 데이터 조회 방지
- [ ] 즉시 로딩(EAGER) 사용 최소화
- [ ] 대용량 컬렉션 처리 시 스트림 API 활용
- [ ] 메모리 누수 방지 (캐시 사이즈 제한, 참조 정리)

### 모니터링
- [ ] 느린 쿼리 로깅 및 최적화
- [ ] AOP를 활용한 메소드 실행 시간 모니터링
- [ ] Actuator 및 Micrometer를 통한 메트릭 수집
- [ ] APM 도구 적용 (예: Pinpoint, New Relic, Datadog)

## 참고 문헌

- [Spring Data JPA 레퍼런스](mdc:https:/docs.spring.io/spring-data/jpa/docs/current/reference/html)
- [Hibernate 사용자 가이드](mdc:https:/docs.jboss.org/hibernate/orm/5.4/userguide/html_single/Hibernate_User_Guide.html)
- [Spring Caching 가이드](mdc:https:/docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache)
- [High Performance Java Persistence (Vlad Mihalcea)](mdc:https:/vladmihalcea.com/books/high-performance-java-persistence)
- [Java Performance: The Definitive Guide (Scott Oaks)](mdc:https:/www.oreilly.com/library/view/java-performance-the/9781449363512)
