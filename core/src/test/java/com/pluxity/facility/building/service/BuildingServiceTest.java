package com.pluxity.facility.building.service;

import com.pluxity.facility.building.Building;
import com.pluxity.facility.building.BuildingRepository;
import com.pluxity.facility.building.BuildingService; // Import the service under test
import com.pluxity.facility.building.dto.BuildingCreateRequest;
import com.pluxity.facility.building.dto.BuildingResponse;
import com.pluxity.facility.building.dto.BuildingUpdateRequest;
import com.pluxity.facility.building.mapper.BuildingMapper;
import com.pluxity.facility.facility.Facility;
import com.pluxity.facility.facility.FacilityService;
import com.pluxity.facility.facility.dto.FacilityCreateRequest;
import com.pluxity.facility.facility.dto.FacilityResponse;
import com.pluxity.facility.facility.dto.FacilityUpdateRequest;
import com.pluxity.facility.facility.dto.FacilityHistoryResponse; // Import for history test
import com.pluxity.facility.floor.dto.FloorRequest;
import com.pluxity.facility.floor.dto.FloorResponse;
import com.pluxity.facility.strategy.FloorStrategy;
import com.pluxity.global.exception.CustomException;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.HttpStatus;

import java.util.Collections;
import java.util.List;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;
import static org.assertj.core.api.Assertions.assertThat;


@ExtendWith(MockitoExtension.class)
class BuildingServiceTest {

    @Mock
    private BuildingRepository buildingRepository;

    @Mock
    private FacilityService facilityService;

    @Mock
    private FloorStrategy floorStrategy;

    @Mock
    private BuildingMapper buildingMapper;

    @InjectMocks
    private BuildingService buildingService;

    private Building building;
    private Facility facility;
    private BuildingCreateRequest createRequest;
    private BuildingUpdateRequest updateRequest;
    private BuildingResponse buildingResponseDto;
    private FacilityCreateRequest facilityCreateRequest;
    private FacilityUpdateRequest facilityUpdateRequest;
    private FacilityResponse facilityResponseDto;

    @BeforeEach
    void setUp() {
        // Corrected FacilityCreateRequest and FacilityUpdateRequest based on typical record structure
        facilityCreateRequest = new FacilityCreateRequest("Test Fac", "F001", "Desc Fac", null, null);
        facilityUpdateRequest = new FacilityUpdateRequest("New Fac Name", "F002", "New Desc Fac", null, null);

        building = new Building("Test Building Name", "Test Building Description");
        building.setId(1L);
        facility = building.getFacility();
        facility.setId(10L);
        facility.updateCode("B001");
        // Facility name & desc are set by Building's constructor via Facility's constructor

        createRequest = new BuildingCreateRequest(facilityCreateRequest, List.of(new FloorRequest("1F", 1, null)));
        updateRequest = new BuildingUpdateRequest(facilityUpdateRequest, List.of(new FloorRequest("B1", 0, null)));

        facilityResponseDto = new FacilityResponse(facility.getId(), facility.getCode(), facility.getName(), facility.getDescription(), null, null);
        buildingResponseDto = new BuildingResponse(building.getId(), facilityResponseDto, Collections.emptyList());
    }

    @Test
    @DisplayName("save: 빌딩 생성 시 ID를 반환한다")
    void save_shouldCreateBuildingAndReturnId() {
        // Arrange
        when(facilityService.save(any(Facility.class), any(FacilityCreateRequest.class)))
            .thenAnswer(invocation -> {
                Facility facArg = invocation.getArgument(0);
                FacilityCreateRequest reqArg = invocation.getArgument(1);
                facArg.setId(20L);
                facArg.updateCode(reqArg.code());
                facArg.updateName(reqArg.name()); // Ensure name from request is used for facility
                facArg.updateDescription(reqArg.description()); // Ensure desc from request is used
                return facArg;
            });

        // Mock the building instance that will be returned by repository.save()
        // This instance should have its ID set.
        Building buildingToSave = new Building(createRequest.facility().name(), createRequest.facility().description());
        // Set ID on the building instance that save method will return
        Building savedBuildingWithId = new Building(createRequest.facility().name(), createRequest.facility().description());
        savedBuildingWithId.setId(1L); // Simulate ID generated by repository
        // Ensure the facility within savedBuildingWithId also reflects changes from facilityService.save
        Facility facilityInSavedBuilding = savedBuildingWithId.getFacility();
        facilityInSavedBuilding.setId(20L);
        facilityInSavedBuilding.updateCode(createRequest.facility().code());


        when(buildingRepository.save(any(Building.class))).thenReturn(savedBuildingWithId);

        // Act
        Long savedBuildingId = buildingService.save(createRequest);

        // Assert
        assertNotNull(savedBuildingId);
        assertEquals(savedBuildingWithId.getId(), savedBuildingId); // Check against ID of returned mock
        verify(facilityService).save(any(Facility.class), eq(createRequest.facility()));
        verify(buildingRepository).save(any(Building.class));
        if (createRequest.floors() != null) {
            verify(floorStrategy, times(createRequest.floors().size())).save(any(Facility.class), any(FloorRequest.class));
        }
    }

    @Test
    @DisplayName("findById: 빌딩이 존재할 경우 BuildingResponse를 반환한다")
    void findById_whenBuildingExists_shouldReturnBuildingResponse() {
        // Arrange
        when(buildingRepository.findById(1L)).thenReturn(Optional.of(building));

        // Manually create the expected FacilityResponse that buildingMapper would produce for building.getFacility()
        FacilityResponse expectedFacilityResponse = new FacilityResponse(
            facility.getId(), facility.getCode(), facility.getName(), facility.getDescription(),
            facility.getDrawingFileId(), facility.getThumbnailFileId()
        );
        // Manually create the BuildingResponse that buildingMapper would produce
        BuildingResponse mappedDto = new BuildingResponse(building.getId(), expectedFacilityResponse, null); // Floors ignored by mapper

        when(buildingMapper.toBuildingResponse(building)).thenReturn(mappedDto);

        List<FloorResponse> floorResponses = List.of(new FloorResponse(1L, "1F", 1, null, null));
        when(floorStrategy.findAllByFacility(facility)).thenReturn(floorResponses);

        // Act
        BuildingResponse actualResponse = buildingService.findById(1L);

        // Assert
        assertNotNull(actualResponse);
        assertEquals(building.getId(), actualResponse.id());
        assertEquals(facility.getName(), actualResponse.facility().name());
        assertEquals(floorResponses.size(), actualResponse.floors().size());
        verify(buildingMapper).toBuildingResponse(building);
    }

    @Test
    @DisplayName("findById: 빌딩이 존재하지 않을 경우 CustomException을 던진다")
    void findById_whenBuildingNotFound_shouldThrowCustomException() {
        // Arrange
        when(buildingRepository.findById(1L)).thenReturn(Optional.empty());

        // Act & Assert
        CustomException exception = assertThrows(CustomException.class, () -> buildingService.findById(1L));
        assertEquals(HttpStatus.NOT_FOUND, exception.getHttpStatus());
    }

    @Test
    @DisplayName("findAll: 빌딩 목록을 BuildingResponse 리스트로 반환한다")
    void findAll_shouldReturnListOfBuildingResponses() {
        // Arrange
        // Similar setup as findById for the mapping part
        FacilityResponse expectedFacilityResponse = new FacilityResponse(
            facility.getId(), facility.getCode(), facility.getName(), facility.getDescription(),
            facility.getDrawingFileId(), facility.getThumbnailFileId()
        );
        BuildingResponse mappedDto = new BuildingResponse(building.getId(), expectedFacilityResponse, null);

        when(buildingRepository.findAll()).thenReturn(List.of(building));
        when(buildingMapper.toBuildingResponse(building)).thenReturn(mappedDto);
        List<FloorResponse> floorResponses = List.of(new FloorResponse(1L, "1F", 1, null, null));
        when(floorStrategy.findAllByFacility(facility)).thenReturn(floorResponses);

        // Act
        List<BuildingResponse> responses = buildingService.findAll();

        // Assert
        assertThat(responses).isNotNull().hasSize(1);
        BuildingResponse firstResponse = responses.get(0);
        assertThat(firstResponse.id()).isEqualTo(building.getId());
        assertThat(firstResponse.facility().name()).isEqualTo(facility.getName());
        assertThat(firstResponse.floors()).hasSize(1);
        verify(buildingMapper).toBuildingResponse(building);
    }

    @Test
    @DisplayName("update: 빌딩이 존재할 경우 업데이트를 수행한다")
    void update_whenBuildingExists_shouldUpdateAndSave() {
        // Arrange
        when(buildingRepository.findById(1L)).thenReturn(Optional.of(building));
        // facilityService.update is void, no thenReturn needed
        when(buildingRepository.save(any(Building.class))).thenReturn(building); // save returns the saved entity

        // Act
        buildingService.update(1L, updateRequest);

        // Assert
        verify(facilityService).update(eq(facility.getId()), eq(updateRequest.facility()));
        verify(floorStrategy).delete(facility);
        verify(floorStrategy, times(updateRequest.floors().size())).save(eq(facility), any(FloorRequest.class));
        verify(buildingRepository).save(building);
    }

    @Test
    @DisplayName("update: 빌딩이 존재하지 않을 경우 CustomException을 던진다")
    void update_whenBuildingNotFound_shouldThrowException() {
        when(buildingRepository.findById(1L)).thenReturn(Optional.empty());
        assertThrows(CustomException.class, () -> buildingService.update(1L, updateRequest));
    }

    @Test
    @DisplayName("delete: 빌딩이 존재할 경우 빌딩과 관련 층을 삭제한다")
    void delete_whenBuildingExists_shouldDeleteBuildingAndFloors() {
        // Arrange
        when(buildingRepository.findById(1L)).thenReturn(Optional.of(building));
        // delete methods are void

        // Act
        buildingService.delete(1L);

        // Assert
        verify(floorStrategy).delete(facility);
        verify(buildingRepository).delete(building);
    }

    @Test
    @DisplayName("delete: 빌딩이 존재하지 않을 경우 CustomException을 던진다")
    void delete_whenBuildingNotFound_shouldThrowException() {
        when(buildingRepository.findById(1L)).thenReturn(Optional.empty());
        assertThrows(CustomException.class, () -> buildingService.delete(1L));
    }

    @Test
    @DisplayName("findFacilityHistories: 빌딩이 존재할 경우 FacilityService를 호출한다")
    void findFacilityHistories_whenBuildingExists_shouldCallFacilityService() {
        when(buildingRepository.findById(1L)).thenReturn(Optional.of(building));
        when(facilityService.findFacilityHistories(facility.getId())).thenReturn(Collections.emptyList());

        List<FacilityHistoryResponse> histories = buildingService.findFacilityHistories(1L);

        assertThat(histories).isNotNull();
        verify(facilityService).findFacilityHistories(facility.getId());
    }

    @Test
    @DisplayName("findFacilityHistories: 빌딩이 존재하지 않을 경우 CustomException을 던진다")
    void findFacilityHistories_whenBuildingNotFound_shouldThrowException() {
        when(buildingRepository.findById(1L)).thenReturn(Optional.empty());
        assertThrows(CustomException.class, () -> buildingService.findFacilityHistories(1L));
    }
}
